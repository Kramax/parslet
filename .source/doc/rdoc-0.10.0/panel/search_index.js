var search_data = {"index":{"searchIndex":["parslet","atoms","alternative","base","entity","lookahead","named","precedence","re","repetition","sequence","str","classmethods","errortree","expression","treetop","parser","transform","parsefailed","parser","pattern","context","sequencebind","simplebind","subtreebind","transform",">>()",">>()","absnt?()","any()","apply()","apply()","apply()","as()","ascii_tree()","call_on_match()","can_bind?()","can_bind?()","can_bind?()","cause()","cause()","cause()","cause?()","each_match()","element_match()","element_match_ary_single()","element_match_binding()","element_match_hash()","error_tree()","error_tree()","error_tree()","error_tree()","error_tree()","error_tree()","error_tree()","exp()","fail()","flatten()","flatten_repetition()","flatten_sequence()","included()","inspect()","inspect()","match()","match()","maybe()","method_missing()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","nodes()","parse()","parse()","parslet()","precedence()","prsnt?()","recurse_array()","recurse_hash()","recurse_into()","repeat()","root()","rule()","rule()","rule()","rules()","rules()","sequence()","simple()","str()","subtree()","success()","to_parslet()","to_s()","to_s()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","to_s_inner()","transform()","transform_elt()","try()","try()","try()","try()","try()","try()","try()","variable_name()","|()","|()","readme","parslet.rb","atoms.rb","alternative.rb","base.rb","entity.rb","lookahead.rb","named.rb","re.rb","repetition.rb","sequence.rb","str.rb","error_tree.rb","expression.rb","treetop.rb","parser.rb","pattern.rb","binding.rb","context.rb","transform.rb"],"longSearchIndex":["lib/parslet.rb","parslet","parslet::atoms","parslet::atoms","parslet::atoms","parslet::atoms","parslet::atoms","parslet::atoms","parslet::atoms","parslet::atoms","parslet::atoms","parslet::atoms","parslet","parslet","parslet","parslet::expression","parslet::expression::treetop","parslet::expression::treetop","parslet","parslet","parslet","parslet::pattern","parslet::pattern","parslet::pattern","parslet::pattern","parslet","parslet::atoms::base","parslet::atoms::sequence","parslet::atoms::base","parslet","parslet::atoms::base","parslet::atoms::named","parslet::transform","parslet::atoms::base","parslet::errortree","parslet::pattern","parslet::pattern::sequencebind","parslet::pattern::simplebind","parslet::pattern::subtreebind","parslet::atoms::base","parslet::atoms::repetition","parslet::errortree","parslet::atoms::base","parslet::pattern","parslet::pattern","parslet::pattern","parslet::pattern","parslet::pattern","parslet::atoms::alternative","parslet::atoms::base","parslet::atoms::entity","parslet::atoms::lookahead","parslet::atoms::named","parslet::atoms::repetition","parslet::atoms::sequence","parslet","parslet::atoms::lookahead","parslet::atoms::base","parslet::atoms::base","parslet::atoms::base","parslet","parslet::atoms::base","parslet::pattern::subtreebind","parslet","parslet::pattern","parslet::atoms::base","parslet::pattern::context","parslet::atoms::alternative","parslet::atoms::entity","parslet::atoms::lookahead","parslet::atoms::named","parslet::atoms::re","parslet::atoms::repetition","parslet::atoms::sequence","parslet::atoms::str","parslet::errortree","parslet::expression","parslet::pattern","parslet::pattern::context","parslet::transform","parslet::errortree","parslet::atoms::base","parslet::expression","parslet::atoms::entity","parslet::atoms::base","parslet::atoms::base","parslet::transform","parslet::transform","parslet::pattern","parslet::atoms::base","parslet::classmethods","parslet::classmethods","parslet::transform","parslet::transform","parslet::transform","parslet::transform","parslet","parslet","parslet","parslet","parslet::atoms::lookahead","parslet::expression","parslet::atoms::base","parslet::errortree","parslet::atoms::alternative","parslet::atoms::entity","parslet::atoms::lookahead","parslet::atoms::named","parslet::atoms::re","parslet::atoms::repetition","parslet::atoms::sequence","parslet::atoms::str","parslet::expression","parslet::transform","parslet::atoms::alternative","parslet::atoms::entity","parslet::atoms::lookahead","parslet::atoms::re","parslet::atoms::repetition","parslet::atoms::sequence","parslet::atoms::str","parslet::pattern::subtreebind","parslet::atoms::alternative","parslet::atoms::base","files/readme.html","files/lib/parslet_rb.html","files/lib/parslet/atoms_rb.html","files/lib/parslet/atoms/alternative_rb.html","files/lib/parslet/atoms/base_rb.html","files/lib/parslet/atoms/entity_rb.html","files/lib/parslet/atoms/lookahead_rb.html","files/lib/parslet/atoms/named_rb.html","files/lib/parslet/atoms/re_rb.html","files/lib/parslet/atoms/repetition_rb.html","files/lib/parslet/atoms/sequence_rb.html","files/lib/parslet/atoms/str_rb.html","files/lib/parslet/error_tree_rb.html","files/lib/parslet/expression_rb.html","files/lib/parslet/expression/treetop_rb.html","files/lib/parslet/parser_rb.html","files/lib/parslet/pattern_rb.html","files/lib/parslet/pattern/binding_rb.html","files/lib/parslet/pattern/context_rb.html","files/lib/parslet/transform_rb.html"],"info":[["Parslet","lib/parslet.rb","classes/Parslet.html"," < ","A simple parser generator library. Typical usage would look like this:  require 'parslet' class MyParser",1],["Atoms","Parslet","classes/Parslet/Atoms.html"," < ","",1],["Alternative","Parslet::Atoms","classes/Parslet/Atoms/Alternative.html"," < Parslet::Atoms::Base","Alternative during matching. Contains a list of parslets that is tried each one in turn. Only fails if",1],["Base","Parslet::Atoms","classes/Parslet/Atoms/Base.html"," < Object","Base class for all parslets, handles orchestration of calls and implements a lot of the operator and",1],["Entity","Parslet::Atoms","classes/Parslet/Atoms/Entity.html"," < Parslet::Atoms::Base","This wraps pieces of parslet definition and gives them a name. The wrapped piece is lazily evaluated",1],["Lookahead","Parslet::Atoms","classes/Parslet/Atoms/Lookahead.html"," < Parslet::Atoms::Base","Either positive or negative lookahead, doesn't consume its input.  Example:  str('foo').prsnt?   # matches",1],["Named","Parslet::Atoms","classes/Parslet/Atoms/Named.html"," < Parslet::Atoms::Base","Names a match to influence tree construction.  Example:  str('foo')            # will return 'foo', ",1],["Precedence","Parslet::Atoms","classes/Parslet/Atoms/Precedence.html"," < ","The precedence module controls parenthesis during the #inspect printing of parslets. It is not relevant",1],["Re","Parslet::Atoms","classes/Parslet/Atoms/Re.html"," < Parslet::Atoms::Base","Matches a special kind of regular expression that only ever matches one character at a time. Useful members",1],["Repetition","Parslet::Atoms","classes/Parslet/Atoms/Repetition.html"," < Parslet::Atoms::Base","Matches a parslet repeatedly.  Example:  str('a').repeat(1,3)  # matches 'a' at least once, but at most",1],["Sequence","Parslet::Atoms","classes/Parslet/Atoms/Sequence.html"," < Parslet::Atoms::Base","A sequence of parslets, matched from left to right. Denoted by '>>' Example:  str('a') >> str('b')  #",1],["Str","Parslet::Atoms","classes/Parslet/Atoms/Str.html"," < Parslet::Atoms::Base","Matches a string of characters.  Example:  str('foo') # matches 'foo' ",1],["ClassMethods","Parslet","classes/Parslet/ClassMethods.html"," < ","",1],["ErrorTree","Parslet","classes/Parslet/ErrorTree.html"," < Object","A tree structure that contains parse error messages. This can be used to give the user a detailed report",1],["Expression","Parslet","classes/Parslet/Expression.html"," < Object","Allows specifying rules as strings using the exact same grammar that treetop does, minus the actions.",1],["Treetop","Parslet::Expression","classes/Parslet/Expression/Treetop.html"," < Object","",1],["Parser","Parslet::Expression::Treetop","classes/Parslet/Expression/Treetop/Parser.html"," < Parslet::Parser","",1],["Transform","Parslet::Expression::Treetop","classes/Parslet/Expression/Treetop/Transform.html"," < Parser::Transform","",1],["ParseFailed","Parslet","classes/Parslet/ParseFailed.html"," < Exception","Raised when the parse failed to match or to consume all its input. It contains the message that should",1],["Parser","Parslet","classes/Parslet/Parser.html"," < Object","The base class for all your parsers. Use as follows:  require 'parslet' class MyParser < Parslet::Parser",1],["Pattern","Parslet","classes/Parslet/Pattern.html"," < Object","Matches trees against expressions. Trees are formed by arrays and hashes for expressing membership and",1],["Context","Parslet::Pattern","classes/Parslet/Pattern/Context.html"," < BlankSlate","Provides a context for tree transformations to run in. The context allows accessing each of the bindings",1],["SequenceBind","Parslet::Pattern","classes/Parslet/Pattern/SequenceBind.html"," < Parslet::Pattern::SubtreeBind","Binds a symbol to a sequence of simple leafs ([element1, element2, ...]) ",1],["SimpleBind","Parslet::Pattern","classes/Parslet/Pattern/SimpleBind.html"," < Parslet::Pattern::SubtreeBind","Binds a symbol to a simple subtree, one that is not either a sequence of elements or a collection of",1],["SubtreeBind","Parslet::Pattern","classes/Parslet/Pattern/SubtreeBind.html"," < Struct.new(:symbol)","Used internally for representing a bind placeholder in a Parslet::Transform pattern. This is the superclass",1],["Transform","Parslet","classes/Parslet/Transform.html"," < Object","Transforms an expression tree into something else. The transformation performs a depth-first, post-order",1],[">>","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000009","(parslet)","",2],[">>","Parslet::Atoms::Sequence","classes/Parslet/Atoms/Sequence.html#M000049","(parslet)","",2],["absnt?","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000011","()","",2],["any","Parslet","classes/Parslet.html#M000100","()","Returns an atom matching any character.  ",2],["apply","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000006","(io)","",2],["apply","Parslet::Atoms::Named","classes/Parslet/Atoms/Named.html#M000038","(io)","",2],["apply","Parslet::Transform","classes/Parslet/Transform.html#M000088","(obj)","",2],["as","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000013","(name)","",2],["ascii_tree","Parslet::ErrorTree","classes/Parslet/ErrorTree.html#M000061","()","Returns an ascii tree representation of the causes of this node and its children.  ",2],["call_on_match","Parslet::Pattern","classes/Parslet/Pattern.html#M000080","(tree, bindings, block)","Executes the block on the bindings obtained by #match, if such a match can be made. Contains the logic",2],["can_bind?","Parslet::Pattern::SequenceBind","classes/Parslet/Pattern/SequenceBind.html#M000076","(subtree)","",2],["can_bind?","Parslet::Pattern::SimpleBind","classes/Parslet/Pattern/SimpleBind.html#M000073","(subtree)","",2],["can_bind?","Parslet::Pattern::SubtreeBind","classes/Parslet/Pattern/SubtreeBind.html#M000071","(subtree)","",2],["cause","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000026","()","Cause should return the current best approximation of this parslet of what went wrong with the parse.",2],["cause","Parslet::Atoms::Repetition","classes/Parslet/Atoms/Repetition.html#M000050","()","",2],["cause","Parslet::ErrorTree","classes/Parslet/ErrorTree.html#M000060","()","",2],["cause?","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000028","()","",2],["each_match","Parslet::Pattern","classes/Parslet/Pattern.html#M000078","(tree)","Searches the given +tree+ for this pattern, yielding the subtrees that match to the block.  Example:",2],["element_match","Parslet::Pattern","classes/Parslet/Pattern.html#M000085","(tree, exp, bindings)","Returns true if the tree element given by +tree+ matches the expression given by +exp+. This match must",2],["element_match_ary_single","Parslet::Pattern","classes/Parslet/Pattern.html#M000092","(sequence, exp, bindings)","",2],["element_match_binding","Parslet::Pattern","classes/Parslet/Pattern.html#M000086","(tree, exp, bindings)","",2],["element_match_hash","Parslet::Pattern","classes/Parslet/Pattern.html#M000093","(tree, exp, bindings)","",2],["error_tree","Parslet::Atoms::Alternative","classes/Parslet/Atoms/Alternative.html#M000004","()","",2],["error_tree","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000027","()","Error tree returns what went wrong here plus what went wrong inside  subexpressions as a tree. The error",2],["error_tree","Parslet::Atoms::Entity","classes/Parslet/Atoms/Entity.html#M000022","()","",2],["error_tree","Parslet::Atoms::Lookahead","classes/Parslet/Atoms/Lookahead.html#M000036","()","",2],["error_tree","Parslet::Atoms::Named","classes/Parslet/Atoms/Named.html#M000043","()","",2],["error_tree","Parslet::Atoms::Repetition","classes/Parslet/Atoms/Repetition.html#M000051","()","",2],["error_tree","Parslet::Atoms::Sequence","classes/Parslet/Atoms/Sequence.html#M000057","()","",2],["exp","Parslet","classes/Parslet.html#M000101","(str)","A special kind of atom that allows embedding whole treetop expressions into parslet construction.  Example:",2],["fail","Parslet::Atoms::Lookahead","classes/Parslet/Atoms/Lookahead.html#M000033","(io)","",2],["flatten","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000014","(value)","",2],["flatten_repetition","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000016","(list)","",2],["flatten_sequence","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000015","(list)","",2],["included","Parslet","classes/Parslet.html#M000095","(base)","",2],["inspect","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000024","()","",2],["inspect","Parslet::Pattern::SubtreeBind","classes/Parslet/Pattern/SubtreeBind.html#M000070","()","",2],["match","Parslet","classes/Parslet.html#M000098","(obj)","Returns an atom matching a character class. This is essentially a regular expression, but you should",2],["match","Parslet::Pattern","classes/Parslet/Pattern.html#M000079","(subtree)","Decides if the given subtree matches this pattern. Returns the bindings made on a successful match or",2],["maybe","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000008","()","",2],["method_missing","Parslet::Pattern::Context","classes/Parslet/Pattern/Context.html#M000075","(sym, *args, &block)","",2],["new","Parslet::Atoms::Alternative","classes/Parslet/Atoms/Alternative.html#M000000","(*alternatives)","",2],["new","Parslet::Atoms::Entity","classes/Parslet/Atoms/Entity.html#M000018","(name, context, block)","",2],["new","Parslet::Atoms::Lookahead","classes/Parslet/Atoms/Lookahead.html#M000031","(bound_parslet, positive=true)","",2],["new","Parslet::Atoms::Named","classes/Parslet/Atoms/Named.html#M000037","(parslet, name)","",2],["new","Parslet::Atoms::Re","classes/Parslet/Atoms/Re.html#M000040","(match)","",2],["new","Parslet::Atoms::Repetition","classes/Parslet/Atoms/Repetition.html#M000045","(parslet, min, max, tag=:repetition)","",2],["new","Parslet::Atoms::Sequence","classes/Parslet/Atoms/Sequence.html#M000048","(*parslets)","",2],["new","Parslet::Atoms::Str","classes/Parslet/Atoms/Str.html#M000053","(str)","",2],["new","Parslet::ErrorTree","classes/Parslet/ErrorTree.html#M000058","(parslet, *children)","",2],["new","Parslet::Expression","classes/Parslet/Expression.html#M000065","(str, opts={})","",2],["new","Parslet::Pattern","classes/Parslet/Pattern.html#M000077","(pattern)","",2],["new","Parslet::Pattern::Context","classes/Parslet/Pattern/Context.html#M000074","(bindings)","",2],["new","Parslet::Transform","classes/Parslet/Transform.html#M000084","(&block)","",2],["nodes","Parslet::ErrorTree","classes/Parslet/ErrorTree.html#M000059","()","",2],["parse","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000005","(io)","",2],["parse","Parslet::Expression","classes/Parslet/Expression.html#M000067","(str)","Parses the string and returns a parse tree. ",2],["parslet","Parslet::Atoms::Entity","classes/Parslet/Atoms/Entity.html#M000020","()","",2],["precedence","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000017","(prec)","",2],["prsnt?","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000012","()","",2],["recurse_array","Parslet::Transform","classes/Parslet/Transform.html#M000094","(ary)","",2],["recurse_hash","Parslet::Transform","classes/Parslet/Transform.html#M000091","(hsh)","",2],["recurse_into","Parslet::Pattern","classes/Parslet/Pattern.html#M000081","(expr, &block)","Handles preorder, depth-first recursion through the +expr+ given.  ",2],["repeat","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000007","(min=0, max=nil)","",2],["root","Parslet::ClassMethods","classes/Parslet/ClassMethods.html#M000096","(name)","Define the parsers #root function. This is the place where you start  parsing; if you have a rule for",2],["rule","Parslet::ClassMethods","classes/Parslet/ClassMethods.html#M000097","(name, &definition)","Define an entity for the parser. This generates a method of the same name that can be used as part of",2],["rule","Parslet::Transform","classes/Parslet/Transform.html#M000087","(expression, &block)","",2],["rule","Parslet::Transform","classes/Parslet/Transform.html#M000082","(expression, &block)","Define a rule for the transform subclass.  ",2],["rules","Parslet::Transform","classes/Parslet/Transform.html#M000083","()","Allows accessing the class' rules ",2],["rules","Parslet::Transform","classes/Parslet/Transform.html#M000089","()","Allow easy access to all rules, the ones defined in the instance and the  ones predefined in a subclass",2],["sequence","Parslet","classes/Parslet.html#M000102","(symbol)","Returns a placeholder for a tree transformation that will only match a  sequence of elements. The +symbol+",2],["simple","Parslet","classes/Parslet.html#M000103","(symbol)","Returns a placeholder for a tree transformation that will only match  simple elements. This matches everything",2],["str","Parslet","classes/Parslet.html#M000099","(str)","Returns an atom matching the +str+ given.  Example:  str('class')      # will match 'class'  ",2],["subtree","Parslet","classes/Parslet.html#M000104","(symbol)","Returns a placeholder for tree transformation patterns that will match  any kind of subtree.  Example:",2],["success","Parslet::Atoms::Lookahead","classes/Parslet/Atoms/Lookahead.html#M000034","(io)","",2],["to_parslet","Parslet::Expression","classes/Parslet/Expression.html#M000068","()","Turns this expression into a parslet. ",2],["to_s","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000023","(outer_prec)","",2],["to_s","Parslet::ErrorTree","classes/Parslet/ErrorTree.html#M000062","()","Alias for #ascii_tree",2],["to_s_inner","Parslet::Atoms::Alternative","classes/Parslet/Atoms/Alternative.html#M000003","(prec)","",2],["to_s_inner","Parslet::Atoms::Entity","classes/Parslet/Atoms/Entity.html#M000021","(prec)","",2],["to_s_inner","Parslet::Atoms::Lookahead","classes/Parslet/Atoms/Lookahead.html#M000035","(prec)","",2],["to_s_inner","Parslet::Atoms::Named","classes/Parslet/Atoms/Named.html#M000039","(prec)","",2],["to_s_inner","Parslet::Atoms::Re","classes/Parslet/Atoms/Re.html#M000042","(prec)","",2],["to_s_inner","Parslet::Atoms::Repetition","classes/Parslet/Atoms/Repetition.html#M000047","(prec)","",2],["to_s_inner","Parslet::Atoms::Sequence","classes/Parslet/Atoms/Sequence.html#M000056","(prec)","",2],["to_s_inner","Parslet::Atoms::Str","classes/Parslet/Atoms/Str.html#M000055","(prec)","",2],["transform","Parslet::Expression","classes/Parslet/Expression.html#M000066","(tree)","Transforms the parse tree into a parslet expression.  ",2],["transform_elt","Parslet::Transform","classes/Parslet/Transform.html#M000090","(elt)","",2],["try","Parslet::Atoms::Alternative","classes/Parslet/Atoms/Alternative.html#M000002","(io)","",2],["try","Parslet::Atoms::Entity","classes/Parslet/Atoms/Entity.html#M000019","(io)","",2],["try","Parslet::Atoms::Lookahead","classes/Parslet/Atoms/Lookahead.html#M000032","(io)","",2],["try","Parslet::Atoms::Re","classes/Parslet/Atoms/Re.html#M000041","(io)","",2],["try","Parslet::Atoms::Repetition","classes/Parslet/Atoms/Repetition.html#M000046","(io)","",2],["try","Parslet::Atoms::Sequence","classes/Parslet/Atoms/Sequence.html#M000052","(io)","",2],["try","Parslet::Atoms::Str","classes/Parslet/Atoms/Str.html#M000054","(io)","",2],["variable_name","Parslet::Pattern::SubtreeBind","classes/Parslet/Pattern/SubtreeBind.html#M000069","()","",2],["|","Parslet::Atoms::Alternative","classes/Parslet/Atoms/Alternative.html#M000001","(parslet)","",2],["|","Parslet::Atoms::Base","classes/Parslet/Atoms/Base.html#M000010","(parslet)","",2],["README","files/README.html","files/README.html","","INTRODUCTION  A small library that implements a PEG grammar. PEG means Parsing Expression Grammars [1].",3],["parslet.rb","files/lib/parslet_rb.html","files/lib/parslet_rb.html","","",3],["atoms.rb","files/lib/parslet/atoms_rb.html","files/lib/parslet/atoms_rb.html","","",3],["alternative.rb","files/lib/parslet/atoms/alternative_rb.html","files/lib/parslet/atoms/alternative_rb.html","","Alternative during matching. Contains a list of parslets that is tried each one in turn. Only fails if",3],["base.rb","files/lib/parslet/atoms/base_rb.html","files/lib/parslet/atoms/base_rb.html","","Base class for all parslets, handles orchestration of calls and implements a lot of the operator and",3],["entity.rb","files/lib/parslet/atoms/entity_rb.html","files/lib/parslet/atoms/entity_rb.html","","This wraps pieces of parslet definition and gives them a name. The wrapped piece is lazily evaluated",3],["lookahead.rb","files/lib/parslet/atoms/lookahead_rb.html","files/lib/parslet/atoms/lookahead_rb.html","","Either positive or negative lookahead, doesn't consume its input.  Example:  str('foo').prsnt?   # matches",3],["named.rb","files/lib/parslet/atoms/named_rb.html","files/lib/parslet/atoms/named_rb.html","","Names a match to influence tree construction.  Example:  str('foo')            # will return 'foo', ",3],["re.rb","files/lib/parslet/atoms/re_rb.html","files/lib/parslet/atoms/re_rb.html","","Matches a special kind of regular expression that only ever matches one character at a time. Useful members",3],["repetition.rb","files/lib/parslet/atoms/repetition_rb.html","files/lib/parslet/atoms/repetition_rb.html","","Matches a parslet repeatedly.  Example:  str('a').repeat(1,3)  # matches 'a' at least once, but at most",3],["sequence.rb","files/lib/parslet/atoms/sequence_rb.html","files/lib/parslet/atoms/sequence_rb.html","","A sequence of parslets, matched from left to right. Denoted by '>>' Example:  str('a') >> str('b')  #",3],["str.rb","files/lib/parslet/atoms/str_rb.html","files/lib/parslet/atoms/str_rb.html","","Matches a string of characters.  Example:  str('foo') # matches 'foo' ",3],["error_tree.rb","files/lib/parslet/error_tree_rb.html","files/lib/parslet/error_tree_rb.html","","A tree structure that contains parse error messages. This can be used to give the user a detailed report",3],["expression.rb","files/lib/parslet/expression_rb.html","files/lib/parslet/expression_rb.html","","Allows specifying rules as strings using the exact same grammar that treetop does, minus the actions.",3],["treetop.rb","files/lib/parslet/expression/treetop_rb.html","files/lib/parslet/expression/treetop_rb.html","","",3],["parser.rb","files/lib/parslet/parser_rb.html","files/lib/parslet/parser_rb.html","","The base class for all your parsers. Use as follows:  require 'parslet' class MyParser < Parslet::Parser",3],["pattern.rb","files/lib/parslet/pattern_rb.html","files/lib/parslet/pattern_rb.html","","Matches trees against expressions. Trees are formed by arrays and hashes for expressing membership and",3],["binding.rb","files/lib/parslet/pattern/binding_rb.html","files/lib/parslet/pattern/binding_rb.html","","Used internally for representing a bind placeholder in a Parslet::Transform pattern. This is the superclass",3],["context.rb","files/lib/parslet/pattern/context_rb.html","files/lib/parslet/pattern/context_rb.html","","",3],["transform.rb","files/lib/parslet/transform_rb.html","files/lib/parslet/transform_rb.html","","",3]]}}