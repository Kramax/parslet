---
title: Transformation
layout: default
---

Parslet parsers output deep nested hashes. Those are nice for printing, but 
hard to work with. The structure of the nested hashes is determined by the
grammar and can thus vary largely. Testing for the presence of individual 
keys would produce code that is hard to read and maintain. 

This is why parslet also comes with a hash transformation engine. To construct
such a transform, you have to derive from <code>Parslet::Transform</code>: 

{% highlight ruby %} 
class MyTransform < Parslet::Transform
  rule('a') { 'b' }
end
MyTransform.new.apply('a') # => 'b'
{% endhighlight %}

This is a transformation that replaces all 'a's with 'b's. A transformation
rule has two parts: A *pattern* (here: <code>'a'</code>) and an *action block*
(<code>{ 'b' }</code>).

The engine will go through the input and traverse the tree in depth-first
post-order fashion. This means that for a given tree node, it will first visit
the children and only then look at the node itself. While traversing, all
rules are tested in the order in which they are defined. If a rule matches, the
corresponding tree is _replaced_ by whatever the action block returns.

Here's another way of saying the same thing, perhaps more in line with what 
you need as a user of Parslet: <code>Parslet::Transform</code> is what allows
you to transform the PORO-trees magically into a real abstract syntax tree. The
rule definitions are the futuristic nano-machines that act on tree leaves first, 
eating them away and replacing them with contraptions of your own design. Here's
how that might look like in Ruby: 

{% highlight ruby %} 
tree = {:left => {:int => '1'}, 
        :op   => '+', 
        :right => {:int => '2'}}
        
class Trans < Parslet::Transform
  rule(:int => simple(:x)) { Integer(x) }
end
Trans.new.apply(tree)     # => {:op=>"+", :right=>2, :left=>1}
{% endhighlight %}

You can start thinking about the leaves first, transforming those <code>:int
=> '1'</code> into real Ruby integers. This incremental (test driven!)
approach will prevent your intermediary tree from turning into grey goo
from too many nano-machines. Rules should in general be simple and transform
a small part of the tree into a more useful variant. Turns out that if we were
looking for an interpreter, one more rule will give us evaluation: 

{% highlight ruby %} 
# ... snippage ...

class Trans < Parslet::Transform
  rule(:int => simple(:x)) { Integer(x) }
  rule(:op => '+', :left => simple(:l), :right => simple(:r)) { l + r }
end
Trans.new.apply(tree)     # => 3
{% endhighlight %}

Cool, isn't it? To recap: parslet intentionally spits out deep nested hashes, 
because it also gives you the tool to work with those. Turning the intermediary
trees into something useful is really easy. 

h2. Working with Captures

What is this <code>simple(symbol)</code> business all about, you might ask.
Glad you do.

h3. Simple captures

Transform allows you to specify patterns that have wildcards in them. The
wildcards match part of the tree, but at the same time capture it for working
on it in your action block. The wildcard

{% highlight ruby %} 
simple(:x)
{% endhighlight %}

will match any object BUT hashes or arrays. While this is obviously useful
for capturing strings, you can also capture other 'simple' (as opposed to 
composed) objects of your own creation. <code>simple(:x)</code> would thus match
all of these objects: 

{% highlight ruby %} 
"a string"
123
Foo.new(:some, :class, :instance)
{% endhighlight %}

If you think about what you'll be doing to your intermediary trees, replacing
leaves with more useful objects, <code>simple</code> really makes good sense, 
since it will stop you from matching entire subtrees. 

h3. Matching Repetitions and Sequences

Some patterns (like repetitions and sequences) produce arrays of objects as
result. You can use <code>simple(...)</code> to replace all parts of these
arrays with your own objects, but you cannot replace the array as a whole. 
This is the purpose of <code>sequence(symbol)</code>: 

{% highlight ruby %} 
sequence(:x)
{% endhighlight %}

will match all of these: 

{% highlight ruby %} 
['a', 'b', 'c']
['a', 'a', 'a']
[Foo.new, Bar.new]
{% endhighlight %}

but not

{% highlight ruby %} 
[{:a => :b}]
[['a', 'b']]
{% endhighlight %}

Like its smaller brother, <code>sequence</code> is very picky about what it
consumes and what not. All for the same reasons. 

h3. Matching entire subtrees

So you don't want to listen and really want that big gun with the foot aiming
addon. You'll be needing <code>subtree(symbol)</code>. It always matches. 
Nuff said. 

h3. Matching context

A match always binds in a context. The context consists of all bindings
that were previously made. If you reuse the same symbol for two consecutive
matches within the same pattern, the engine will assume that you want these
two matched objects to be equal (under <code>==</code>). This allows to 
specify constraints on your matches that would need code to express otherwise: 





h2. Transformation rules

h3. patterns

h3. Action blocks: Two flavors 

h3. why doesn't it loop around?

h3. Ruledefs: Two flavors


