---
layout: default
title: Get Started
---

THIS IS UNFINISHED, PLEASE BE PATIENT.

Let's develop a small language that allows for simple computation together. 
Here's a valid input file for that language: 

{% highlight ruby %} 
puts(1 + 2)
puts(4 + 2)
{% endhighlight %}

To install the parslet library, please do a 

{% highlight bash %} 
gem install parslet
{% endhighlight %}

Now let's write the first part of our parser. For now, let's just recognize
simple numbers like '1' or '42'.

{% highlight ruby %} 
require 'parslet' 

class Mini < Parslet::Parser
  rule(:integer) { match('[0-9]').repeat(1) }
  root(:integer)
end

p Mini.new.parse("132432")
{% endhighlight %}

Running this example will print "132432". Congratulations! You just have
written your first parser. Running it on the input '<code>puts(1)</code>' will
not work yet. Let's see what happens in case of a failure:

{% highlight ruby %} 
Mini.new.parse("puts(1)") # raises Parslet::ParseFailed
{% endhighlight %}

Here's the error message provided by that exception: "Expected at least 1 of [0-9] at line 1 char 1." parslet tries to find a number there, but can't find
one.

There are just two lines to the definition of this parser, let's go through them: 

{% highlight ruby %} 
rule(:integer) { match('[0-9]').repeat(1) }
{% endhighlight %}

<code>rule</code> lets you create a new parser rule. Inside the block of that
<code>:integer</code> rule, you find <code>match('[0-9]').repeat(1)</code>. This says: "match a character that is in the range <code>0-9</code>, then 
match any number of those, but at least match one."

{% highlight ruby %} 
root(:integer)
{% endhighlight %}

That second line just says: Start parsing at the rule called
<code>:integer</code>.

h2. Addition

Let's go for simple addition. We'll have to allow for spaces in our input,
since those help make code readable. 

{% highlight ruby %} 
rule(:space)  { match('\s').repeat(1) }
rule(:space?) { space.maybe }
{% endhighlight %}

Two things are new here: (and both in the second line)

* you can use ('call') other rules in your rules 
* <code>.maybe</code>, the same as <code>.repeat(0,1)</code>, indicating that
  the thing before it is maybe present once in the input.
  
Essentially, you can think about parslet construction as instructing Ruby to
"parse this" and "parse that". Calling other rules can be looked at in the 
same way; you tell Ruby to go off, parse that subrule and then come back with
the results. This helps when thinking about rule recursion. For example, a 
self-recursive rule like this one will of course create an endless loop: 

{% highlight ruby %} 
rule(:infinity) {
  infinity >> str(';')
}
{% endhighlight %}

Even though infinity seems to be delimited by ';', in reality, infinity is
very long, especially towards the end. There is no way of knowing for the
parser when to stop processing <code>infinity</code> and start reading
semicolons. Ergo, we need to make sure we talk about concrete items that
consume input first, and then do recursion. This way we ensure that our
grammar terminates, since in a way, it is like a normal program.

Here's the full parser:

{% highlight ruby %}  
class Mini < Parslet::Parser
  rule(:integer)    { match('[0-9]').repeat(1) >> space? }
  
  rule(:space)      { match('\s').repeat(1) }
  rule(:space?)     { space.maybe }
  
  rule(:operator)   { match('[+]') >> space? }
  
  rule(:sum)        { integer >> operator >> expression }
  rule(:expression) { sum | integer }

  root :expression
end

def parse(str)
  mini = Mini.new
  print "Parsing #{str}: "
  
  p mini.parse(str)
rescue Parslet::ParseFailed => error
  puts error, mini.root.error_tree
end

parse "1 + 2 + 3"
{% endhighlight %}

As you can see, the parser got decorated with the <code>space?</code> idiom.
Every atom of our language consumes the space right after it. This is a useful
convention that makes top level rules (the important ones) look cleaner.

Note also the addition of <code>:operator</code>, <code>:sum</code> and
<code>:expression</code>. The runner code has been extended a bit, so as to
throw nice explanations of what went wrong when a parse failure is
encountered. Running the code on '<code>1++2</code>' for example outputs:

{% highlight bash %} 
Parsing 1 ++ 2: Don't know what to do with ++ 2 at line 1 char 3.
`- Unknown error in SUM | INTEGER
   |- Failed to match sequence (INTEGER OPERATOR EXPRESSION) at line 1 char 4.
   |  `- Unknown error in [0-9]{1, } SPACE?
   |     `- Failed to match \\s at line 1 char 4.
   `- Unknown error in [0-9]{1, } SPACE?
      `- Failed to match \\s at line 1 char 4.
{% endhighlight %}

This is what parslet calls an <code>#error_tree</code>. Not only the output of your parser, 
but also its grammar is constructed like a tree. When things go wrong, every
branch of the tree has its own reasons for not accepting a given input. The 
<code>#error_tree</code> method returns those reasons. 

Our grammar has essentially two branches, <code>SUM</code> and
<code>INTEGER</code>. Can you see why all rules expect a space at character 4?

h2. Tree output (and what to do about it)

But if we leave the negative examples for a second; what happens if the parse
succeeds? It turns out, not much: 

{% highlight bash %} 
* ruby 002.rb 
Parsing 1 + 2 + 3: "1 + 2 + 3"
{% endhighlight %}

The code we now have parses the input successfully, but doesn't do much else. 
Out of the box, parslet only performs one of the two functions of a parser. It
accepts input, but doesn't structure it. To do that, we have to point out to
parslet the pieces that we're interested in. Look at this bit: 

{% highlight ruby%} 
# Without structure: just strings.
str('ooo').parse('ooo')                           # => 'ooo'
str('o').repeat.parse('ooo')                      # => 'ooo'

# Added structure: .as(...)
str('ooo').as(:ex1).parse('ooo')                  # => {:ex1=>"ooo"}
str('o').as(:ex2a).repeat.as(:ex2b).parse('ooo')  # => {:ex2b=>[{:ex2a=>"o"}, {:ex2a=>"o"}, {:ex2a=>"o"}]}
{% endhighlight %}

You get to name things the way you want! This is also free. Seriously: parslet
requires you to add all the structure to its output. Annotate important parts
of your grammar with <code>.as(:symbol)</code> and get back a tree-like
structure composed of hashes (sequence), arrays (repetition) and strings (like
we had initially).

Once you start naming things, you'll notice that what you don't name,
disappears. Parslet assumes that _what you don't name is unimportant_.

{% highlight ruby%} 
parser =  str('a').as(:a) >> str(' ').maybe >> 
          str('+').as(:o) >> str(' ').maybe >> 
          str('b').as(:b)
parser.parse('a + b') # => {:a=>"a", :o=>"+", :b=>"b"}
{% endhighlight%}

h2. Making the parser complete

Let's look at the complete parser definition that also allows for function
calls like we postulated at the beginning.

{% highlight ruby%} 
class Mini < Parslet::Parser
  # Single character rules
  rule(:lparen)     { str('(') >> space? }
  rule(:rparen)     { str(')') >> space? }
  rule(:comma)      { str(',') >> space? }

  rule(:space)      { match('\s').repeat(1) }
  rule(:space?)     { space.maybe }

  # Things
  rule(:integer)    { match('[0-9]').repeat(1) >> space? }
  rule(:identifier) { match['a-z'].repeat(1) }
  rule(:operator)   { match('[+]') >> space? }
  
  # Grammar parts
  rule(:sum)        { integer.as(:left) >> operator.as(:op) >> expression.as(:right) }
  rule(:arglist)    { expression.as(:arg) >> (comma >> expression.as(:arg)).repeat }
  rule(:funcall)    { identifier.as(:funcall) >> lparen >> arglist.as(:arglist) >> rparen }
  
  rule(:expression) { funcall | sum | integer }
  root :expression
end
{% endhighlight %}

That's really all there is to it -- our language is a really simple language. 
When fed with a string like '<code>puts(1+2+3, 45)</code>, our parser outputs
the following: 

{% highlight ruby %} 
# Ruby 1.9 hash syntax for easier reading
{
  funcall: 'puts', 
  arglist: [
    {arg: {left: '1', op: '+ ', right: {left: '2', op: '+ ', right: '3'}}}, 
    {arg: '45'}
  ]
}
{% endhighlight %}

Parslet calls this the _intermediary tree_. There are really only three types
of nodes in this tree: 

* Hashes form a node that has subtrees that have names
* Arrays form a node storing a collection of sub-nodes anonymously
* Strings are the leaves

The intermediary tree is where parslet excels in our eyes. The format is 
easy to work with and to read. And it corresponds already much to what you 
would wish for when constructing an abstract syntax tree. It corresponds to
this: 

!imgs/ast.png!

Note that some information we have above is only implicit in this illustration. 
Our intermediary tree uses an array for the ordering of the argument list of 
<code>puts</code>. 

h2. Where to go from here: An Interpreter