---
layout: default
title: Get Started
---

THIS IS UNFINISHED, PLEASE BE PATIENT.

Let's develop a small language that allows for simple computation together. 
Here's a valid input file for that language: 

{% highlight ruby %} 
puts(1 + 2)
puts(4 + 2)
{% endhighlight %}

To install the parslet library, please do a 

{% highlight bash %} 
gem install parslet
{% endhighlight %}

Now let's write the first part of our parser. For now, let's just recognize
simple numbers like '1' or '42'.

{% highlight ruby %} 
require 'parslet' 

class Mini < Parslet::Parser
  rule(:integer) { match('[0-9]').repeat(1) }
  root(:integer)
end

p Mini.new.parse("132432")
{% endhighlight %}

Running this example will print "132432". Congratulations! You just have
written your first parser. Running it on the input '<code>puts(1)</code>' will
not work yet. Let's see what happens in case of a failure:

{% highlight ruby %} 
Mini.new.parse("puts(1)") # raises Parslet::ParseFailed
{% endhighlight %}

Here's the error message provided by that exception: "Expected at least 1 of [0-9] at line 1 char 1." parslet tries to find a number there, but can't find
one.

There are just two lines to the definition of this parser, let's go through them: 

{% highlight ruby %} 
rule(:integer) { match('[0-9]').repeat(1) }
{% endhighlight %}

<code>rule</code> lets you create a new parser rule. Inside the block of that
<code>:integer</code> rule, you find <code>match('[0-9]').repeat(1)</code>. This says: "match a character that is in the range <code>0-9</code>, then 
match any number of those, but at least match one."

{% highlight ruby %} 
root(:integer)
{% endhighlight %}

That second line just says: Start parsing at the rule called
<code>:integer</code>.

h2. Addition

Let's go for simple addition. We'll have to allow for spaces in our input,
since those help make code readable. Here are two rules that will serve us
good:

{% highlight ruby %} 
rule(:space)  { match('\s').repeat(1) }
rule(:space?) { space.maybe }
{% endhighlight %}

Two things are new here: (and both in the second line)

* you can use ('call') other rules in your rules 
* <code>.maybe</code>, the same as <code>.repeat(0,1)</code>, indicating that
  the thing before it is maybe present once in the input.
  
Here's the full parser, including a small problem that will be interesting to
talk about later on: 

{% highlight ruby %}  
class Mini < Parslet::Parser
  rule(:integer)    { match('[0-9]').repeat(1) >> space? }
  
  rule(:space)      { match('\s').repeat(1) }
  rule(:space?)     { space.maybe }
  
  rule(:operator)   { match('[+]') >> space? }
  
  rule(:sum)        { integer >> operator >> expression }
  rule(:expression) { sum | integer }

  root :expression
end

def parse(str)
  mini = Mini.new
  print "Parsing #{str}: "
  
  p mini.parse(str)
rescue Parslet::ParseFailed => error
  puts error, mini.root.error_tree
end

parse "1 + 2 + 3"
{% endhighlight %}

As you can see, the parser got decorated with the <code>space?</code> idiom.
Every atom of our language consumes the space right after it. This is a useful
convention that makes top level rules (the important ones) look cleaner.

Note also the addition of <code>:operator</code>, <code>:sum</code> and
<code>:expression</code>. The runner code has been extended a bit, so as to
throw nice explanations of what went wrong when a parse failure is
encountered. Running the code on '<code>1++2</code>' for example outputs:

{% highlight bash %} 
Parsing 1 ++ 2: Don't know what to do with ++ 2 at line 1 char 3.
`- Unknown error in SUM | INTEGER
   |- Failed to match sequence (INTEGER OPERATOR EXPRESSION) at line 1 char 4.
   |  `- Unknown error in [0-9]{1, } SPACE?
   |     `- Failed to match \\s at line 1 char 4.
   `- Unknown error in [0-9]{1, } SPACE?
      `- Failed to match \\s at line 1 char 4.
{% endhighlight %}

This is what parslet calls an <code>#error_tree</code>. Not only the output of your parser, 
but also its grammar is constructed like a tree. When things go wrong, every
branch of the tree has its own reasons for not accepting a given input. The 
<code>#error_tree</code> method returns those reasons. 

Our grammar has essentially two branches, <code>SUM</code> and
<code>INTEGER</code>. Can you see why all rules expect a space at character 4?

h2. Making the parser complete

Let's look at the complete parser definition that also allows for function
calls like we postulated at the beginning.