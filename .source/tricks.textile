---
title: Tricks for common situations
layout: default
---

h2. Matching EOF (End Of File)

The best and simplest way of doing this is: Don't. Parslet will raise
<code>Parslet::ParseFailed</code> if your input cannot be completely consumed
by the grammar. So the best way of matching EOF is to implicitly match it
by not having a failed parse. 

{% highlight ruby %} 
str('a').repeat
{% endhighlight %}

The above sample looks like it might match a bunch of 'a's, but really it
matches those 'a's and the end of input. With parslet, all you have to do
is think of _matching all legal input_. EOF has no representation and cannot
be matched. 

The common case of matching lines ended by a newline would then look like this: 

{% highlight ruby %} 
rule(:line)     { ... }
rule(:eol)      { match['\n\r'].repeat(1) }

rule(:eol_line) { line >> eol}
rule(:document) { eol_line.repeat >> line.maybe }
{% endhighlight %}
 
This allows for a document containing only <code>eol_line</code>s, one that
has any number of <code>eol_line</code>s and then an extra lone
<code>line</code>, or a completely empty document.

h2. Error reports

If your grammar fails and you're aching to know why, here's a bit of exception
handling code that will help you out: 

{% highlight ruby %} 
begin
  parser.parse(some_input)
rescue Parslet::ParseFailed => error
  puts error, parser.root.error_tree
end
{% endhighlight %}

This should print something akin to: 

{% highlight text %} 
Parsing 1++2: Don't know what to do with ++2 at line 1 char 2.
`- Unknown error in SUM / INTEGER
   |- Failed to match sequence (INTEGER OPERATOR EXPRESSION) at line 1 char 3.
   |  `- Unknown error in [0-9]{1, } SPACE?
   |     `- Expected at least 1 of \\s at line 1 char 2.
   |        `- Failed to match \\s at line 1 char 3.
   `- Unknown error in [0-9]{1, } SPACE?
      `- Expected at least 1 of \\s at line 1 char 2.
         `- Failed to match \\s at line 1 char 3.
{% endhighlight %}

These error reports are probably the fastest way to know exactly where you
went wrong (or where your input is wrong, which is aequivalent).