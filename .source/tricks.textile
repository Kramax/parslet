---
title: Tricks for common situations
layout: default
---

h2. Matching EOF (End Of File)

The best and simplest way of doing this is: Don't. Parslet will raise
<code>Parslet::ParseFailed</code> if your input cannot be completely consumed
by the grammar. So the best way of matching EOF is to implicitly match it
by not having a failed parse. 

{% highlight ruby %} 
str('a').repeat
{% endhighlight %}

The above sample looks like it might match a bunch of 'a's, but really it
matches those 'a's and the end of input. With parslet, all you have to do
is think of _matching all legal input_. EOF has no representation and cannot
be matched. 

The common case of matching lines ended by a newline would then look like this: 

{% highlight ruby %} 
rule(:line)     { ... }
rule(:eol)      { match['\n\r'].repeat(1) }

rule(:eol_line) { line >> eol}
rule(:document) { eol_line.repeat >> line.maybe }
{% endhighlight %}
 
This allows for a document containing only <code>eol_line</code>s, one that
has any number of <code>eol_line</code>s and then an extra lone
<code>line</code>, or a completely empty document.

And just to show that there is always (at least) two ways to answer a question, 
here's something that also works:

{% highlight ruby %} 
rule(:eof) { any.absnt? }
{% endhighlight %}

h2. Matching Strings Case Insensitive

Parslet is fully hackable: You can use code to create parsers easily. Here's
how I would match a string in case insensitive manner: 

{% highlight ruby %} 
def stri(str)
  key_chars = str.split(//)
  key_chars.
    collect! { |char| match["#{char.upcase}#{char.downcase}"] }.
    reduce(:>>)
end

# Constructs a parser using a Parser Expression Grammar 
stri('keyword').parse "kEyWoRd"     # => "kEyWoRd"
{% endhighlight %}

h2. Testing

Parslet helps you to create parsers that are in turn created out of many small
parsers. It is really turtles all the way down. Imagine you have a complex 
parser: 

{% highlight ruby %} 
class ComplexParser < Parslet::Parser
  root :lots_of_stuff
  
  rule(:lots_of_stuff) { ... }
  
  # and many lines later: 
  rule(:simple_rule) { str('a') }
end
{% endhighlight %}

Also imagine that the parser (as a whole) fails to consume the 'a' that 
<code>simple_rule</code> is talking about. 

This kind of problem can very often be fixed by bisecting it into two possible
problems. Either: 

# the <code>lots_of_stuff</code> rule somehow doesn't place <code>simple_rule</code>
  in the right context or
# the <code>simple_rule</code> simply (hah!) fails to match its input. 

I find it very useful in this situation to eliminate 2. from our options: 

{% highlight ruby %} 
require 'parslet/rig/rspec'

describe ComplexParser  do
  let(:parser) { ComplexParser.new }
  context "simple_rule" do
    it "should consume 'a'" do
      parser.simple_rule.should parse('a')
    end 
  end
end
{% endhighlight %}

Parslet parsers have one method per rule. These methods return valid parsers
for a subset of your grammar. 

h2. Error reports

If your grammar fails and you're aching to know why, here's a bit of exception
handling code that will help you out: 

{% highlight ruby %} 
begin
  parser.parse(some_input)
rescue Parslet::ParseFailed => error
  puts error, parser.root.error_tree
end
{% endhighlight %}

This should print something akin to: 

{% highlight text %} 
Parsing 1++2: Don't know what to do with ++2 at line 1 char 2.
`- Unknown error in SUM / INTEGER
   |- Failed to match sequence (INTEGER OPERATOR EXPRESSION) at line 1 char 3.
   |  `- Unknown error in [0-9]{1, } SPACE?
   |     `- Expected at least 1 of \\s at line 1 char 2.
   |        `- Failed to match \\s at line 1 char 3.
   `- Unknown error in [0-9]{1, } SPACE?
      `- Expected at least 1 of \\s at line 1 char 2.
         `- Failed to match \\s at line 1 char 3.
{% endhighlight %}

These error reports are probably the fastest way to know exactly where you
went wrong (or where your input is wrong, which is aequivalent).