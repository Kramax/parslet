---
layout: default
title: Snippage
---

= Language Atoms

PEG-style grammars build on a very small number of atoms, or parslets. In
fact, only three types of parslets exist. Here's how to match a string: 

  str('a string')

This matches the string 'a string' literally and nothing else. If your input
doesn't contain the string, it will fail. Here's how to match a character
set: 

  match('[abc]')

This matches 'a', 'b' or 'c'. The string matched will always have a length
of 1; to match longer strings, please see the title below. The last parslet
of the three is 'any':

  any

'any' functions like the dot in regular expressions - it matches any single
character. 

= Combination and Repetition

Parslets only get useful when combined to grammars. To combine one parslet
with the other, you have 4 kinds of methods available: repeat and maybe, >>
(sequence), | (alternation), absnt? and prsnt?.

  str('a').repeat     # any number of 'a's, including 0
  str('a').maybe      # maybe there'll be an 'a', maybe not   

Parslets can be joined using >>. This means: Match the left parslet, then
match the right parslet. 

  str('a') >> str('b')  # would match 'ab'

Keep in mind that all combination and repetition operators themselves return
a parslet. You can combine the result again: 

  ( str('a') >> str('b') ) >> str('c')    # would match 'abc'
   
The slash ('|') indicates alternatives: 

  str('a') | str('b')   # would match 'a' OR 'b'

The left side of an alternative is matched first; if it matches, the right
side is never looked at. 

The absnt? and prsnt? qualifiers allow looking at input without consuming
it: 

  str('a').absnt?               # will match if at the current position there is an 'a'. 
  str('a').absnt? >> str('b')   # check for 'a' then match 'b'

This means that the second example will not match any input; when the second
part is parsed, the first part has asserted the presence of 'a', and thus
str('b') cannot match. The prsnt? method is the opposite of absnt?, it
asserts presence. 
   
More documentation on these methods can be found in Parslets::Atoms::Base.

= Intermediary Parse Trees

As you have probably seen above, you can hand input (strings or StringIOs) to
your parslets like this: 

  parslet.parse(str)    

This returns an intermediary parse tree or raises an exception
(Parslet::ParseFailed) when the input is not well formed. 

Intermediary parse trees are essentially just Plain Old Ruby Objects. (PORO
technology as we call it.) Parslets try very hard to return sensible stuff; 
it is quite easy to use the results for the later stages of your program. 

Here a few examples and what their intermediary tree looks like: 

  str('foo').parse('foo')                           # => 'foo'
  (str('f') >> str('o') >> str('o')).parse('foo')   # => 'foo'
  
Naming parslets

Construction of lambda blocks

= Intermediary Tree transformation

The intermediary parse tree by itself is most often not very useful. Its
form is volatile; changing your parser in the slightest might produce
profound changes in the generated trees. 

Generally you will want to construct a more stable tree using your own
carefully crafted representation of the domain. Parslet provides you with
an elegant way of transmogrifying your intermediary tree into the output
format you choose. This is achieved by transformation rules such as this
one: 

  transform.rule(:literal => {:string => :_x}) { |d| 
    StringLit.new(*d.values) }

The above rule will transform a subtree looking like this: 

                             :literal
                                  |     
                              :string    
                                  |
                             "somestring"

into just this: 

                              StringLit
                              value: "somestring"


= Further documentation

Please see the examples subdirectory of the distribution for more examples.
Check out 'rooc' (github.com/kschiess/rooc) as well - it uses parslet for
compiler construction. 
      

Other Ruby projects that work on the same topic are: 
http://wiki.github.com/luikore/rsec/
http://github.com/mjijackson/citrus
http://github.com/nathansobo/treetop
