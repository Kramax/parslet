<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html;charset=UTF-8" http-equiv="Content-type" />
    <title>
      parslet -
      Snippage
    </title>
    <meta content="Kaspar Schiess (http://absurd.li)" name="author" />
    <link href="css/site.css" rel="stylesheet" type="text/css" />
    <link href="css/pygments.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="everything">
      <div class="main_menu">
        <img alt="Parslet Logo" src="imgs/parsley_logo.png" />
        <ul>
          <li><a href="index.html">about</a></li>
          <li><a href="get-started.html">get started</a></li>
          <li><a href="install.html">install</a></li>
          <li><a href="documentation.html">documentation</a></li>
          <li><a href="contribute.html">contribute</a></li>
        </ul>
      </div>
      <div class="content">
        <h1>Snippage</h1>
        <p>= Language Atoms</p>
        <p><span class="caps">PEG</span>-style grammars build on a very small number of atoms, or parslets. In
        fact, only three types of parslets exist. Here&#8217;s how to match a string:</p>
        str(&#8216;a string&#8217;)
        <p>This matches the string &#8216;a string&#8217; literally and nothing else. If your input
        doesn&#8217;t contain the string, it will fail. Here&#8217;s how to match a character
        set:</p>
        match(&#8216;[abc]&#8217;)
        <p>This matches &#8216;a&#8217;, &#8216;b&#8217; or &#8216;c&#8217;. The string matched will always have a length
        of 1; to match longer strings, please see the title below. The last parslet
        of the three is &#8216;any&#8217;:</p>
        any
        <p>&#8216;any&#8217; functions like the dot in regular expressions &#8211; it matches any single
        character.</p>
        <p>= Combination and Repetition</p>
        <p>Parslets only get useful when combined to grammars. To combine one parslet
        with the other, you have 4 kinds of methods available: repeat and maybe, &gt;&gt;
        (sequence), | (alternation), absnt? and prsnt?.</p>
        str(&#8216;a&#8217;).repeat     # any number of &#8217;a&#8217;s, including 0
        str(&#8216;a&#8217;).maybe      # maybe there&#8217;ll be an &#8216;a&#8217;, maybe not
        <p>Parslets can be joined using &gt;&gt;. This means: Match the left parslet, then
        match the right parslet.</p>
        str(&#8216;a&#8217;) &gt;&gt; str(&#8216;b&#8217;)  # would match &#8216;ab&#8217;
        <p>Keep in mind that all combination and repetition operators themselves return
        a parslet. You can combine the result again:</p>
        ( str(&#8216;a&#8217;) &gt;&gt; str(&#8216;b&#8217;) ) &gt;&gt; str(&#8216;c&#8217;)    # would match &#8216;abc&#8217;
        
        <p>The slash (&#8216;|&#8217;) indicates alternatives:</p>
        str(&#8216;a&#8217;) | str(&#8216;b&#8217;)   # would match &#8216;a&#8217; OR &#8216;b&#8217;
        <p>The left side of an alternative is matched first; if it matches, the right
        side is never looked at.</p>
        <p>The absnt? and prsnt? qualifiers allow looking at input without consuming
        it:</p>
        str(&#8216;a&#8217;).absnt?               # will match if at the current position there is an &#8216;a&#8217;.
        str(&#8216;a&#8217;).absnt? &gt;&gt; str(&#8216;b&#8217;)   # check for &#8216;a&#8217; then match &#8216;b&#8217;
        <p>This means that the second example will not match any input; when the second
        part is parsed, the first part has asserted the presence of &#8216;a&#8217;, and thus
        str(&#8216;b&#8217;) cannot match. The prsnt? method is the opposite of absnt?, it
        asserts presence.</p>
        <p>More documentation on these methods can be found in Parslets::Atoms::Base.</p>
        <p>= Intermediary Parse Trees</p>
        <p>As you have probably seen above, you can hand input (strings or StringIOs) to
        your parslets like this:</p>
        parslet.parse(str)
        <p>This returns an intermediary parse tree or raises an exception
        (Parslet::ParseFailed) when the input is not well formed.</p>
        <p>Intermediary parse trees are essentially just Plain Old Ruby Objects. (<span class="caps">PORO</span>
        technology as we call it.) Parslets try very hard to return sensible stuff; 
        it is quite easy to use the results for the later stages of your program.</p>
        <p>Here a few examples and what their intermediary tree looks like:</p>
        str(&#8216;foo&#8217;).parse(&#8216;foo&#8217;)                           # =&gt; &#8216;foo&#8217;
        (str(&#8216;f&#8217;) &gt;&gt; str(&#8216;o&#8217;) &gt;&gt; str(&#8216;o&#8217;)).parse(&#8216;foo&#8217;)   # =&gt; &#8216;foo&#8217;
        
        <p>Naming parslets</p>
        <p>Construction of lambda blocks</p>
        <p>= Intermediary Tree transformation</p>
        <p>The intermediary parse tree by itself is most often not very useful. Its
        form is volatile; changing your parser in the slightest might produce
        profound changes in the generated trees.</p>
        <p>Generally you will want to construct a more stable tree using your own
        carefully crafted representation of the domain. Parslet provides you with
        an elegant way of transmogrifying your intermediary tree into the output
        format you choose. This is achieved by transformation rules such as this
        one:</p>
        transform.rule(:literal =&gt; {:string =&gt; :_x}) { |d|
        StringLit.new(*d.values) }
        <p>The above rule will transform a subtree looking like this:</p>
        :literal
        |
        :string
        |
        &#8220;somestring&#8221;
        <p>into just this:</p>
        StringLit
        value: &#8220;somestring&#8221;
        <p>= Further documentation</p>
        <p>Please see the examples subdirectory of the distribution for more examples.
        Check out &#8216;rooc&#8217; (github.com/kschiess/rooc) as well &#8211; it uses parslet for
        compiler construction.</p>
        <p>Other Ruby projects that work on the same topic are: 
        http://wiki.github.com/luikore/rsec/
        http://github.com/mjijackson/citrus
        http://github.com/nathansobo/treetop</p>
      </div>
      <div class="copyright">
        <p><span class="caps">MIT</span> License, 2010, &#169; <a href="http://absurd.li">Kaspar Schiess</a><br/>
        Logo by <a href="http://floere.github.com">Florian Hanke</a>, <a href="http://creativecommons.org/licenses/by/1.0/">CC Attribution</a> license</p>
      </div>
      <script type="text/javascript">
        //<![CDATA[
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-16365074-2']);
          _gaq.push(['_trackPageview']);
          
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        //]]>
      </script>
    </div>
  </body>
</html>
