<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html;charset=UTF-8" http-equiv="Content-type" />
    <title>
      parslet -
      Get Started
    </title>
    <meta content="Kaspar Schiess (http://absurd.li)" name="author" />
    <link href="imgs/favicon3.ico" rel="shortcut icon" />
    <link href="css/site.css" rel="stylesheet" type="text/css" />
    <link href="css/pygments.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="everything">
      <div class="main_menu">
        <img alt="Parslet Logo" src="imgs/parsley_logo.png" />
        <ul>
          <li><a href="index.html">about</a></li>
          <li><a href="get-started.html">get started</a></li>
          <li><a href="install.html">install</a></li>
          <li><a href="documentation.html">documentation</a></li>
          <li><a href="contribute.html">contribute</a></li>
        </ul>
      </div>
      <div class="content">
        <h1>Get Started</h1>
        <p>Let&#8217;s develop a small language that allows for simple computation together. 
        Here&#8217;s a valid input file for that language:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="nb">puts</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nb">puts</span><span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        </code></pre>
        </div><p>To install the parslet library, please do a</p>
        <div class="highlight"><pre><code class="bash"> 
        gem install parslet
        </code></pre>
        </div><p>Now let&#8217;s write the first part of our parser. For now, we&#8217;ll just recognize
        simple numbers like &#8216;1&#8217; or &#8216;42&#8217;.</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="nb">require</span> <span class="s1">&#39;parslet&#39;</span> 
        
        <span class="k">class</span> <span class="nc">Mini</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Parser</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span> <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[0-9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">root</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span>
        <span class="k">end</span>
        
        <span class="nb">p</span> <span class="no">Mini</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;132432&quot;</span><span class="p">)</span>
        </code></pre>
        </div><p>Running this example will print &#8220;132432@0&#8221;. Congratulations! You just have
        written your first parser. Running it on the input &#8216;<code>puts(1)</code>&#8217; will
        not work yet. Let&#8217;s see what happens in case of a failure:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="no">Mini</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;puts(1)&quot;</span><span class="p">)</span> <span class="c1"># raises Parslet::ParseFailed</span>
        </code></pre>
        </div><p>Here&#8217;s the error message provided by that exception: &#8220;Expected at least 1 of
        [0-9] at line 1 char 1.&#8221; parslet tries to find a number there, but can&#8217;t find
        one.</p>
        <p>There are just two lines to the definition of this parser, let&#8217;s go through
        them:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">rule</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span> <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[0-9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
        </code></pre>
        </div><p><code>rule</code> lets you create a new parser rule. Inside the block of that
        <code>:integer</code> rule, you find <code>match('[0-9]').repeat(1)</code>.
        This says: &#8220;match a character that is in the range <code>0-9</code>, then
        match any number of those, but at least match one.&#8221;</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">root</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span>
        </code></pre>
        </div><p>That second line just says: Start parsing at the rule called
        <code>:integer</code>.</p>
        <h2>Addition</h2>
        <p>Let&#8217;s go for simple addition. We&#8217;ll have to allow for spaces in our input,
        since those help make code readable.</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">rule</span><span class="p">(</span><span class="ss">:space</span><span class="p">)</span>  <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;\s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
        <span class="n">rule</span><span class="p">(</span><span class="ss">:space?</span><span class="p">)</span> <span class="p">{</span> <span class="n">space</span><span class="o">.</span><span class="n">maybe</span> <span class="p">}</span>
        </code></pre>
        </div><p>Two things are new here: (and both in the second line)</p>
        <ul>
        	<li>you can use (&#8216;call&#8217;) other rules in your rules</li>
        	<li><code>.maybe</code>, the same as <code>.repeat(0,1)</code><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup>, indicating that
          the thing before it is maybe present once in the input.</li>
        </ul>
        <p>Essentially, you can think about parslet rules as instructing Ruby to &#8220;parse
        this&#8221; and &#8220;parse that&#8221;. Calling other rules can be looked at in the same way;
        you tell Ruby to go off, parse that subrule and then come back with the
        results. This helps when thinking about rule recursion. For example, a
        self-recursive rule like this one will of course create an endless loop:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">rule</span><span class="p">(</span><span class="ss">:infinity</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">infinity</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
        <span class="p">}</span>
        </code></pre>
        </div><p>Even though infinity seems to be delimited by &#8216;;&#8217;, in reality, infinity is
        very long, especially towards the end. There is no way of knowing for the
        parser when to stop processing <code>infinity</code> and start reading
        semicolons. Ergo, we need to make sure we talk about concrete items that
        consume input first, and then do recursion. This way we ensure that our
        grammar terminates, since in a way, it is like a normal program.</p>
        <p>Here&#8217;s the full parser:</p>
        <div class="highlight"><pre><code class="ruby">  
        <span class="k">class</span> <span class="nc">Mini</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Parser</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span>    <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[0-9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          
          <span class="n">rule</span><span class="p">(</span><span class="ss">:space</span><span class="p">)</span>      <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;\s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:space?</span><span class="p">)</span>     <span class="p">{</span> <span class="n">space</span><span class="o">.</span><span class="n">maybe</span> <span class="p">}</span>
          
          <span class="n">rule</span><span class="p">(</span><span class="ss">:operator</span><span class="p">)</span>   <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[+]&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          
          <span class="n">rule</span><span class="p">(</span><span class="ss">:sum</span><span class="p">)</span>        <span class="p">{</span> <span class="n">integer</span> <span class="o">&gt;&gt;</span> <span class="n">operator</span> <span class="o">&gt;&gt;</span> <span class="n">expression</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:expression</span><span class="p">)</span> <span class="p">{</span> <span class="n">sum</span> <span class="o">|</span> <span class="n">integer</span> <span class="p">}</span>
        
          <span class="n">root</span> <span class="ss">:expression</span>
        <span class="k">end</span>
        
        <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
          <span class="n">mini</span> <span class="o">=</span> <span class="no">Mini</span><span class="o">.</span><span class="n">new</span>
          <span class="nb">print</span> <span class="s2">&quot;Parsing </span><span class="si">#{</span><span class="n">str</span><span class="si">}</span><span class="s2">: &quot;</span>
          
          <span class="nb">p</span> <span class="n">mini</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
        <span class="k">rescue</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">ParseFailed</span> <span class="o">=&gt;</span> <span class="n">error</span>
          <span class="nb">puts</span> <span class="n">error</span><span class="p">,</span> <span class="n">mini</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">error_tree</span>
        <span class="k">end</span>
        
        <span class="n">parse</span> <span class="s2">&quot;1 + 2 + 3&quot;</span>
        </code></pre>
        </div><p>As you can see, the parser got decorated with the <code>space?</code> idiom.
        Every atom of our language consumes the space right after it. This is a useful
        convention that makes top level rules (the important ones) look cleaner.</p>
        <p>Note also the addition of <code>:operator</code>, <code>:sum</code> and
        <code>:expression</code>. The runner code has been extended a bit, so as to
        throw nice explanations of what went wrong when a parse failure is
        encountered. Running the code on &#8216;<code>1++2</code>&#8217; for example outputs:</p>
        <div class="highlight"><pre><code class="bash"> 
        Parsing 1++2: Don<span class="err">&#39;</span>t know what to <span class="k">do </span>with ++2 at line 1 char 2.
        <span class="sb">`</span>- Unknown error in SUM / INTEGER
           |- Failed to match sequence <span class="o">(</span>INTEGER OPERATOR<span class="o">)</span> at line 1 char 3.
           |  <span class="sb">`</span>- Failed to match sequence <span class="o">([</span>0-9<span class="o">]{</span>1, <span class="o">}</span> SPACE?<span class="o">)</span> at line 1 char 3.
           |     <span class="sb">`</span>- Expected at least 1 of <span class="o">[</span>0-9<span class="o">]</span> at line 1 char 3.
           |        <span class="sb">`</span>- Failed to match <span class="o">[</span>0-9<span class="o">]</span> at line 1 char 3.
           <span class="sb">`</span>- Failed to match sequence <span class="o">([</span>0-9<span class="o">]{</span>1, <span class="o">}</span> SPACE?<span class="o">)</span> at line 1 char 3.
              <span class="sb">`</span>- Expected at least 1 of <span class="o">[</span>0-9<span class="o">]</span> at line 1 char 3.
                 <span class="sb">`</span>- Failed to match <span class="o">[</span>0-9<span class="o">]</span> at line 1 char 3.
        </code></pre>
        </div><p>This is what parslet calls an <code>#error_tree</code>. Not only the output of
        your parser, but also its grammar is constructed like a tree. When things go
        wrong, every branch of the tree has its own reasons for not accepting a given
        input. The <code>#error_tree</code> method returns those reasons.</p>
        <p>Our grammar has essentially two branches, <code>SUM</code> and
        <code>INTEGER</code>. Can you see why all rules expect a space at character 4?</p>
        <h2>Tree output (and what to do about it)</h2>
        <p>But if we leave the negative examples for a second; what happens if the parse
        succeeds? It turns out, not much:</p>
        <div class="highlight"><pre><code class="bash"> 
        * ruby 002.rb 
        Parsing 1 + 2 + 3: <span class="s2">&quot;1 + 2 + 3&quot;</span>@0
        </code></pre>
        </div><p>The only notable difference between input and output is that the output has an
        extra &#8216;@0&#8217; appended to it. This is related to line number tracking and will be
        explained later on (or you can skip ahead and look up
        <code>Parslet::Slice</code>).</p>
        <p>The code we now have parses the input successfully, but doesn&#8217;t do much else. 
        Parslet hasn&#8217;t got its own opinion on what to do with your input. By default, 
        it will just play it back to you. But parslet provides also a method of 
        structuring its output:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="c1"># Without structure: just strings.</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;ooo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;ooo&#39;</span><span class="p">)</span>                           <span class="c1"># =&gt; &quot;ooo&quot;@0</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;ooo&#39;</span><span class="p">)</span>                      <span class="c1"># =&gt; &quot;ooo&quot;@0</span>
        
        <span class="c1"># Added structure: .as(...)</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;ooo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:ex1</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;ooo&#39;</span><span class="p">)</span>                  <span class="c1"># =&gt; {:ex1=&gt;&quot;ooo&quot;@0}</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:ex2a</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:ex2b</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;ooo&#39;</span><span class="p">)</span>  <span class="c1"># =&gt; {:ex2b=&gt;[{:ex2a=&gt;&quot;o&quot;@0}, </span>
                                                          <span class="c1">#             {:ex2a=&gt;&quot;o&quot;@1}, </span>
                                                          <span class="c1">#             {:ex2a=&gt;&quot;o&quot;@2}]}</span>
        </code></pre>
        </div><p>You get to name things the way you want! This is also free. Seriously: parslet
        requires you to add all the structure to its output. Annotate important parts
        of your grammar with <code>.as(:symbol)</code> and get back a tree-like
        structure composed of hashes (sequence), arrays (repetition) and strings (like
        we had initially).</p>
        <p>Once you start naming things, you&#8217;ll notice that what you don&#8217;t name,
        disappears. Parslet assumes that <em>what you don&#8217;t name is unimportant</em>.</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">parser</span> <span class="o">=</span>  <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:a</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">maybe</span> <span class="o">&gt;&gt;</span> 
                  <span class="n">str</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:o</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">maybe</span> <span class="o">&gt;&gt;</span> 
                  <span class="n">str</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:b</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;a + b&#39;</span><span class="p">)</span> <span class="c1"># =&gt; {:b=&gt;&quot;b&quot;@4, :o=&gt;&quot;+&quot;@2, :a=&gt;&quot;a&quot;@0}</span>
        </code></pre>
        </div><p>Think of this like using a highlighter on your input: What is there not to
        like about neon yellow?</p>
        <h2>Making the parser complete</h2>
        <p>Let&#8217;s look at the complete parser definition that also allows for function
        calls:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="k">class</span> <span class="nc">MiniP</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Parser</span>
          <span class="c1"># Single character rules</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:lparen</span><span class="p">)</span>     <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:rparen</span><span class="p">)</span>     <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:comma</span><span class="p">)</span>      <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
        
          <span class="n">rule</span><span class="p">(</span><span class="ss">:space</span><span class="p">)</span>      <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;\s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:space?</span><span class="p">)</span>     <span class="p">{</span> <span class="n">space</span><span class="o">.</span><span class="n">maybe</span> <span class="p">}</span>
        
          <span class="c1"># Things</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span>    <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[0-9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:int</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:identifier</span><span class="p">)</span> <span class="p">{</span> <span class="n">match</span><span class="o">[</span><span class="s1">&#39;a-z&#39;</span><span class="o">].</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:operator</span><span class="p">)</span>   <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[+]&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          
          <span class="c1"># Grammar parts</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:sum</span><span class="p">)</span>        <span class="p">{</span> <span class="n">integer</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">operator</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:op</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">expression</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:right</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:arglist</span><span class="p">)</span>    <span class="p">{</span> <span class="n">expression</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">comma</span> <span class="o">&gt;&gt;</span> <span class="n">expression</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:funcall</span><span class="p">)</span>    <span class="p">{</span> <span class="n">identifier</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:funcall</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">lparen</span> <span class="o">&gt;&gt;</span> <span class="n">arglist</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:arglist</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rparen</span> <span class="p">}</span>
          
          <span class="n">rule</span><span class="p">(</span><span class="ss">:expression</span><span class="p">)</span> <span class="p">{</span> <span class="n">funcall</span> <span class="o">|</span> <span class="n">sum</span> <span class="o">|</span> <span class="n">integer</span> <span class="p">}</span>
          <span class="n">root</span> <span class="ss">:expression</span>
        <span class="k">end</span>
        </code></pre>
        </div><p>That&#8217;s really all there is to it &#8212; our language is a really simple language. 
        When fed with a string like &#8217;<code>puts(1 + 2 + 3, 45)</code>, our parser outputs
        the following:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="c1"># Ruby 1.9 hash syntax for easier reading</span>
        <span class="p">{</span>
          <span class="n">funcall</span><span class="p">:</span> <span class="s1">&#39;puts&#39;</span><span class="err">@</span><span class="mi">0</span><span class="p">,</span> 
          <span class="n">arglist</span><span class="p">:</span> <span class="o">[</span>
            <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="p">{</span>
              <span class="n">left</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="err">@</span><span class="mi">5</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="s1">&#39;+ &#39;</span><span class="err">@</span><span class="mi">7</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">:</span> <span class="s1">&#39;2&#39;</span><span class="err">@</span><span class="mi">9</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="s1">&#39;+ &#39;</span><span class="err">@</span><span class="mi">11</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="err">@</span><span class="mi">13</span><span class="p">}}},</span> 
            <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;45&#39;</span><span class="err">@</span><span class="mi">16</span><span class="p">}</span>
          <span class="o">]</span>
        <span class="p">}</span>
        </code></pre>
        </div><p>Parslet calls this the <em>intermediary tree</em>. There are three types of nodes in
        this tree:</p>
        <ul>
        	<li><strong>Hashes</strong>: a node that has named subtrees</li>
        	<li><strong>Arrays</strong>: a node storing a collection of sub-nodes</li>
        	<li><strong>Strings</strong> are the leaves, containing the <em>accepted source</em></li>
        </ul>
        <p>The format of this tree is easy to work with and to read. Here&#8217;s what the
        above tree would look like as a graphic:</p>
        <p><img src="imgs/ast.png" alt="" /></p>
        <h2>Where to go from here: An Interpreter</h2>
        <p>As nice as the format above is for printing and looking at &#8211; it may be
        difficult at times to get the information out of it again. Let&#8217;s look at how
        to transform the tree:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="k">class</span> <span class="nc">SimpleTransform</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Transform</span>
          <span class="n">rule</span><span class="p">(</span><span class="n">funcall</span><span class="p">:</span> <span class="s1">&#39;puts&#39;</span><span class="p">,</span> <span class="n">arglist</span><span class="p">:</span> <span class="n">sequence</span><span class="p">(</span><span class="ss">:args</span><span class="p">))</span> <span class="p">{</span>
            <span class="s2">&quot;puts(</span><span class="si">#{</span><span class="n">args</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">)&quot;</span>
          <span class="p">}</span>
          <span class="c1"># ... other rules</span>
        <span class="k">end</span>
        
        <span class="n">tree</span> <span class="o">=</span> <span class="p">{</span><span class="n">funcall</span><span class="p">:</span> <span class="s1">&#39;puts&#39;</span><span class="p">,</span> <span class="n">arglist</span><span class="p">:</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span><span class="p">}</span>
        <span class="no">SimpleTransform</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="c1"># =&gt; &quot;puts([1, 2, 3])&quot;</span>
        </code></pre>
        </div><p>Transformation is an entire topic by itself; this will be covered in detail
        <a href="transform.html">later on</a>. To whet your appetite, let me just give you a few
        teasers:</p>
        <ul>
        	<li>Transformations match portions of your tree at any depth, replacing them
          with whatever you decide.</li>
        	<li>In addition to <code>sequence(sym)</code>, there is also
          <code>simple(sym)</code> and <code>subtree(sym)</code>. Those match simple
          strings and entire subtrees respectively. Caution with the latter.</li>
        </ul>
        <p>Here&#8217;s how you would write a somewhat classical interpreter for our little 
        language by using a transformation. Note that from this point on, there is
        not one way to go about this, but thousands; you are really free (and on
        your own):</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="k">class</span> <span class="nc">MiniP</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Parser</span>
          <span class="c1"># Single character rules</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:lparen</span><span class="p">)</span>     <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:rparen</span><span class="p">)</span>     <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:comma</span><span class="p">)</span>      <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
        
          <span class="n">rule</span><span class="p">(</span><span class="ss">:space</span><span class="p">)</span>      <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;\s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:space?</span><span class="p">)</span>     <span class="p">{</span> <span class="n">space</span><span class="o">.</span><span class="n">maybe</span> <span class="p">}</span>
        
          <span class="c1"># Things</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span>    <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[0-9]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:int</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:identifier</span><span class="p">)</span> <span class="p">{</span> <span class="n">match</span><span class="o">[</span><span class="s1">&#39;a-z&#39;</span><span class="o">].</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:operator</span><span class="p">)</span>   <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[+]&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
          
          <span class="c1"># Grammar parts</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:sum</span><span class="p">)</span>        <span class="p">{</span> <span class="n">integer</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">operator</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:op</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">expression</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:right</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:arglist</span><span class="p">)</span>    <span class="p">{</span> <span class="n">expression</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">comma</span> <span class="o">&gt;&gt;</span> <span class="n">expression</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:funcall</span><span class="p">)</span>    <span class="p">{</span> <span class="n">identifier</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:funcall</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">lparen</span> <span class="o">&gt;&gt;</span> <span class="n">arglist</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:arglist</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rparen</span> <span class="p">}</span>
          
          <span class="n">rule</span><span class="p">(</span><span class="ss">:expression</span><span class="p">)</span> <span class="p">{</span> <span class="n">funcall</span> <span class="o">|</span> <span class="n">sum</span> <span class="o">|</span> <span class="n">integer</span> <span class="p">}</span>
          <span class="n">root</span> <span class="ss">:expression</span>
        <span class="k">end</span>
        
        <span class="k">class</span> <span class="nc">IntLit</span>   <span class="o">&lt;</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:int</span><span class="p">)</span>
          <span class="k">def</span> <span class="nf">eval</span><span class="p">;</span> <span class="n">int</span><span class="o">.</span><span class="n">to_i</span><span class="p">;</span> <span class="k">end</span>
        <span class="k">end</span>
        <span class="k">class</span> <span class="nc">Addition</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:left</span><span class="p">,</span> <span class="ss">:right</span><span class="p">)</span> 
          <span class="k">def</span> <span class="nf">eval</span><span class="p">;</span> <span class="n">left</span><span class="o">.</span><span class="n">eval</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">eval</span><span class="p">;</span> <span class="k">end</span>
        <span class="k">end</span>
        <span class="k">class</span> <span class="nc">FunCall</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:args</span><span class="p">);</span> 
          <span class="k">def</span> <span class="nf">eval</span>
            <span class="nb">p</span> <span class="n">args</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="n">s</span><span class="o">.</span><span class="n">eval</span> <span class="p">}</span>
          <span class="k">end</span>
        <span class="k">end</span>
        
        <span class="k">class</span> <span class="nc">MiniT</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Transform</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:int</span> <span class="o">=&gt;</span> <span class="n">simple</span><span class="p">(</span><span class="ss">:int</span><span class="p">))</span>                                          <span class="p">{</span> <span class="no">IntLit</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">int</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:left</span> <span class="o">=&gt;</span> <span class="n">simple</span><span class="p">(</span><span class="ss">:left</span><span class="p">),</span> <span class="ss">:right</span> <span class="o">=&gt;</span> <span class="n">simple</span><span class="p">(</span><span class="ss">:right</span><span class="p">),</span> <span class="ss">:op</span> <span class="o">=&gt;</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>  <span class="p">{</span> <span class="no">Addition</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:funcall</span> <span class="o">=&gt;</span> <span class="s1">&#39;puts&#39;</span><span class="p">,</span> <span class="ss">:arglist</span> <span class="o">=&gt;</span> <span class="n">subtree</span><span class="p">(</span><span class="ss">:arglist</span><span class="p">))</span>             <span class="p">{</span> <span class="no">FunCall</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;puts&#39;</span><span class="p">,</span> <span class="n">arglist</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">end</span>
        
        <span class="n">parser</span> <span class="o">=</span> <span class="no">MiniP</span><span class="o">.</span><span class="n">new</span>
        <span class="n">transf</span> <span class="o">=</span> <span class="no">MiniT</span><span class="o">.</span><span class="n">new</span>
        
        <span class="n">ast</span> <span class="o">=</span> <span class="n">transf</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
          <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span>
            <span class="s1">&#39;puts(1,2,3, 4+5)&#39;</span><span class="p">))</span>
                
        <span class="n">ast</span><span class="o">.</span><span class="n">eval</span>
        </code></pre>
        </div><p>That&#8217;s a bunch of code for printing <code>[1, 2, 3, 9]</code>. Welcome to the
        fantastic world of compiler and interpreter writing!</p>
        <p><sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup> As far as parsing goes. There is a subtle difference between
        <code>#repeat(0,1)</code> and <code>#maybe</code>. Can you figure it out?</p>
      </div>
      <div class="copyright">
        <p><span class="caps">MIT</span> License, 2010, &#169; <a href="http://absurd.li">Kaspar Schiess</a><br/>
        Logo by <a href="http://floere.github.com">Florian Hanke</a>, <a href="http://creativecommons.org/licenses/by/1.0/">CC Attribution</a> license</p>
      </div>
      <script type="text/javascript">
        //<![CDATA[
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-16365074-2']);
          _gaq.push(['_trackPageview']);
          
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        //]]>
      </script>
    </div>
  </body>
</html>
