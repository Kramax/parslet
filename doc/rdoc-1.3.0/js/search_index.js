var search_data = {"index":{"searchIndex":["parslet","atoms","alternative","base","fail","success","canflatten","context","dsl","entity","lookahead","named","re","repetition","sequence","str","bytecode","compiler","address","block","vm","classmethods","errortree","expression","treetop","invalidsliceoperation","parsefailed","parser","visitors","citrus","treetop","pattern","slice","source","transform","unconsumedinput","+()","==()",">>()","absent?()","absnt?()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","accept()","access_cache()","add()","address()","any()","apply()","as()","ascii_tree()","atom()","buffer_pointer()","cache()","call()","call_on_match()","call_ret()","cause()","clear_error()","compile()","current_address()","debug?()","discard_frame()","dump_state()","element_match()","element_match_hash()","emit_block()","enter_frame()","eof?()","error()","error?()","error?()","error_tree()","fetch()","foldl()","fwd_address()","init()","inspect()","inspect()","jump()","line_and_column()","line_and_column()","match()","match()","match()","maybe()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","nodes()","parse()","parse()","parse_traditional()","parse_vm()","parse_with_debug()","parslet()","pop()","pos()","pos=()","present?()","prsnt?()","push()","read()","repeat()","resolve()","root()","rule()","rule()","rule()","run()","sequence()","set_error()","simple()","size()","stop()","store_cache()","str()","subtree()","success?()","to_citrus()","to_f()","to_i()","to_int()","to_parslet()","to_s()","to_s()","to_s()","to_slice()","to_str()","to_sym()","to_treetop()","transform()","try()","value_at()","visit_alternative()","visit_alternative()","visit_alternative()","visit_entity()","visit_entity()","visit_lookahead()","visit_lookahead()","visit_named()","visit_named()","visit_parser()","visit_re()","visit_re()","visit_repetition()","visit_repetition()","visit_repetition()","visit_sequence()","visit_sequence()","visit_str()","visit_str()","warn_about_duplicate_keys()","|()","readme"],"longSearchIndex":["parslet","parslet::atoms","parslet::atoms::alternative","parslet::atoms::base","parslet::atoms::base::fail","parslet::atoms::base::success","parslet::atoms::canflatten","parslet::atoms::context","parslet::atoms::dsl","parslet::atoms::entity","parslet::atoms::lookahead","parslet::atoms::named","parslet::atoms::re","parslet::atoms::repetition","parslet::atoms::sequence","parslet::atoms::str","parslet::bytecode","parslet::bytecode::compiler","parslet::bytecode::compiler::address","parslet::bytecode::compiler::block","parslet::bytecode::vm","parslet::classmethods","parslet::errortree","parslet::expression","parslet::expression::treetop","parslet::invalidsliceoperation","parslet::parsefailed","parslet::parser","parslet::parser::visitors","parslet::parser::visitors::citrus","parslet::parser::visitors::treetop","parslet::pattern","parslet::slice","parslet::source","parslet::transform","parslet::unconsumedinput","parslet::slice#+()","parslet::slice#==()","parslet::atoms::dsl#>>()","parslet::atoms::dsl#absent?()","parslet::atoms::dsl#absnt?()","parslet::atoms::alternative#accept()","parslet::atoms::base#accept()","parslet::atoms::entity#accept()","parslet::atoms::lookahead#accept()","parslet::atoms::named#accept()","parslet::atoms::re#accept()","parslet::atoms::repetition#accept()","parslet::atoms::sequence#accept()","parslet::atoms::str#accept()","parslet::parser#accept()","parslet::bytecode::vm#access_cache()","parslet::bytecode::compiler#add()","parslet::bytecode::compiler::block#address()","parslet::any()","parslet::transform#apply()","parslet::atoms::dsl#as()","parslet::errortree#ascii_tree()","parslet::bytecode::compiler::block#atom()","parslet::bytecode::compiler#buffer_pointer()","parslet::atoms::context#cache()","parslet::bytecode::vm#call()","parslet::transform#call_on_match()","parslet::bytecode::vm#call_ret()","parslet::errortree#cause()","parslet::bytecode::vm#clear_error()","parslet::bytecode::compiler#compile()","parslet::bytecode::compiler#current_address()","parslet::bytecode::vm#debug?()","parslet::bytecode::vm#discard_frame()","parslet::bytecode::vm#dump_state()","parslet::pattern#element_match()","parslet::pattern#element_match_hash()","parslet::bytecode::compiler#emit_block()","parslet::bytecode::vm#enter_frame()","parslet::source#eof?()","parslet::source#error()","parslet::atoms::base::fail#error?()","parslet::atoms::base::success#error?()","parslet::atoms::base#error_tree()","parslet::bytecode::vm#fetch()","parslet::atoms::canflatten#foldl()","parslet::bytecode::compiler#fwd_address()","parslet::bytecode::vm#init()","parslet::bytecode::compiler::address#inspect()","parslet::slice#inspect()","parslet::bytecode::vm#jump()","parslet::slice#line_and_column()","parslet::source#line_and_column()","parslet::match()","parslet::pattern#match()","parslet::slice#match()","parslet::atoms::dsl#maybe()","parslet::atoms::alternative::new()","parslet::atoms::context::new()","parslet::atoms::repetition::new()","parslet::atoms::sequence::new()","parslet::atoms::str::new()","parslet::bytecode::compiler::new()","parslet::bytecode::compiler::address::new()","parslet::bytecode::compiler::block::new()","parslet::bytecode::vm::new()","parslet::expression::new()","parslet::parsefailed::new()","parslet::parser::visitors::citrus::new()","parslet::pattern::new()","parslet::slice::new()","parslet::source::new()","parslet::errortree#nodes()","parslet::atoms::base#parse()","parslet::expression#parse()","parslet::atoms::base#parse_traditional()","parslet::atoms::base#parse_vm()","parslet::atoms::base#parse_with_debug()","parslet::atoms::entity#parslet()","parslet::bytecode::vm#pop()","parslet::source#pos()","parslet::source#pos=()","parslet::atoms::dsl#present?()","parslet::atoms::dsl#prsnt?()","parslet::bytecode::vm#push()","parslet::source#read()","parslet::atoms::dsl#repeat()","parslet::bytecode::compiler::address#resolve()","parslet::parser::root()","parslet::classmethods#rule()","parslet::transform#rule()","parslet::transform::rule()","parslet::bytecode::vm#run()","parslet::sequence()","parslet::bytecode::vm#set_error()","parslet::simple()","parslet::slice#size()","parslet::bytecode::vm#stop()","parslet::bytecode::vm#store_cache()","parslet::str()","parslet::subtree()","parslet::bytecode::vm#success?()","parslet::parser#to_citrus()","parslet::slice#to_f()","parslet::slice#to_i()","parslet::slice#to_int()","parslet::expression#to_parslet()","parslet::bytecode::compiler::address#to_s()","parslet::errortree#to_s()","parslet::slice#to_s()","parslet::slice#to_slice()","parslet::slice#to_str()","parslet::slice#to_sym()","parslet::parser#to_treetop()","parslet::expression#transform()","parslet::atoms::base#try()","parslet::bytecode::vm#value_at()","parslet::bytecode::compiler#visit_alternative()","parslet::parser::visitors::citrus#visit_alternative()","parslet::parser::visitors::treetop#visit_alternative()","parslet::bytecode::compiler#visit_entity()","parslet::parser::visitors::citrus#visit_entity()","parslet::bytecode::compiler#visit_lookahead()","parslet::parser::visitors::citrus#visit_lookahead()","parslet::bytecode::compiler#visit_named()","parslet::parser::visitors::citrus#visit_named()","parslet::bytecode::compiler#visit_parser()","parslet::bytecode::compiler#visit_re()","parslet::parser::visitors::citrus#visit_re()","parslet::bytecode::compiler#visit_repetition()","parslet::parser::visitors::citrus#visit_repetition()","parslet::parser::visitors::treetop#visit_repetition()","parslet::bytecode::compiler#visit_sequence()","parslet::parser::visitors::citrus#visit_sequence()","parslet::bytecode::compiler#visit_str()","parslet::parser::visitors::citrus#visit_str()","parslet::atoms::canflatten#warn_about_duplicate_keys()","parslet::atoms::dsl#|()",""],"info":[["Parslet","","Parslet.html","","<p>A simple parser generator library. Typical usage would look like this:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'parslet'</span>\n\n<span class=\"ruby-keyword\">class</span> <span class=\"ruby-constant\">MyParser</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Parslet::Atoms","","Parslet/Atoms.html","","<p>This is where parslets name comes from: Small parser atoms.\n"],["Parslet::Atoms::Alternative","","Parslet/Atoms/Alternative.html","","<p>Alternative during matching. Contains a list of parslets that is tried each\none in turn. Only fails if …\n"],["Parslet::Atoms::Base","","Parslet/Atoms/Base.html","","<p>Base class for all parslets, handles orchestration of calls and implements\na lot of the operator and …\n"],["Parslet::Atoms::Base::Fail","","Parslet/Atoms/Base/Fail.html","","<p>Internally, all parsing functions return either an instance of Fail  or an\ninstance of Success.\n"],["Parslet::Atoms::Base::Success","","Parslet/Atoms/Base/Success.html","","<p>Internally, all parsing functions return either an instance of Fail  or an\ninstance of Success.\n"],["Parslet::Atoms::CanFlatten","","Parslet/Atoms/CanFlatten.html","","<p>A series of helper functions that have the common topic of flattening \nresult values into the intermediary …\n"],["Parslet::Atoms::Context","","Parslet/Atoms/Context.html","","<p>Helper class that implements a transient cache that maps position and\nparslet object to results. This …\n"],["Parslet::Atoms::DSL","","Parslet/Atoms/DSL.html","","<p>A mixin module that defines operations that can be called on any subclass\nof Parslet::Atoms::Base. These …\n"],["Parslet::Atoms::Entity","","Parslet/Atoms/Entity.html","","<p>This wraps pieces of parslet definition and gives them a name. The wrapped\npiece is lazily evaluated …\n"],["Parslet::Atoms::Lookahead","","Parslet/Atoms/Lookahead.html","","<p>Either positive or negative lookahead, doesn’t consume its input.\n<p>Example:\n\n<pre>str('foo').present? # matches ...</pre>\n"],["Parslet::Atoms::Named","","Parslet/Atoms/Named.html","","<p>Names a match to influence tree construction.\n<p>Example:\n\n<pre>str('foo')            # will return 'foo', \nstr('foo').as(:foo) ...</pre>\n"],["Parslet::Atoms::Re","","Parslet/Atoms/Re.html","","<p>Matches a special kind of regular expression that only ever matches one\ncharacter at a time. Useful members …\n"],["Parslet::Atoms::Repetition","","Parslet/Atoms/Repetition.html","","<p>Matches a parslet repeatedly.\n<p>Example:\n\n<pre>str('a').repeat(1,3)  # matches 'a' at least once, but at most ...</pre>\n"],["Parslet::Atoms::Sequence","","Parslet/Atoms/Sequence.html","","<p>A sequence of parslets, matched from left to right. Denoted by ‘&gt;&gt;’\n<p>Example:\n\n<pre>str('a') &gt;&gt; str('b') ...</pre>\n"],["Parslet::Atoms::Str","","Parslet/Atoms/Str.html","","<p>Matches a string of characters.\n<p>Example:\n\n<pre>str('foo') # matches 'foo'</pre>\n"],["Parslet::Bytecode","","Parslet/Bytecode.html","",""],["Parslet::Bytecode::Compiler","","Parslet/Bytecode/Compiler.html","",""],["Parslet::Bytecode::Compiler::Address","","Parslet/Bytecode/Compiler/Address.html","",""],["Parslet::Bytecode::Compiler::Block","","Parslet/Bytecode/Compiler/Block.html","",""],["Parslet::Bytecode::VM","","Parslet/Bytecode/VM.html","",""],["Parslet::ClassMethods","","Parslet/ClassMethods.html","",""],["Parslet::ErrorTree","","Parslet/ErrorTree.html","","<p>A tree structure that contains parse error messages. This can be used to\ngive the user a detailed report …\n"],["Parslet::Expression","","Parslet/Expression.html","","<p>Allows specifying rules as strings using the exact same grammar that\ntreetop does, minus the actions. …\n"],["Parslet::Expression::Treetop","","Parslet/Expression/Treetop.html","",""],["Parslet::InvalidSliceOperation","","Parslet/InvalidSliceOperation.html","","<p>Raised when trying to do an operation on slices that cannot succeed, like\nadding non-adjacent slices. …\n"],["Parslet::ParseFailed","","Parslet/ParseFailed.html","","<p>Raised when the parse failed to match or to consume all its input. It\ncontains the message that should …\n"],["Parslet::Parser","","Parslet/Parser.html","","<p>The base class for all your parsers. Use as follows:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'parslet'</span>\n\n<span class=\"ruby-keyword\">class</span> <span class=\"ruby-constant\">MyParser</span> <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-constant\">Parslet</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Parser</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["Parslet::Parser::Visitors","","Parslet/Parser/Visitors.html","",""],["Parslet::Parser::Visitors::Citrus","","Parslet/Parser/Visitors/Citrus.html","",""],["Parslet::Parser::Visitors::Treetop","","Parslet/Parser/Visitors/Treetop.html","",""],["Parslet::Pattern","","Parslet/Pattern.html","","<p>Matches trees against expressions. Trees are formed by arrays and hashes\nfor expressing membership and …\n"],["Parslet::Slice","","Parslet/Slice.html","","<p>A slice is a small part from the parse input. A slice mainly behaves like\nany other string, except that …\n"],["Parslet::Source","","Parslet/Source.html","","<p>Wraps the input IO to parslet. The interface defined by this class is \nsmaller than what IO offers, but …\n"],["Parslet::Transform","","Parslet/Transform.html","","<p>Transforms an expression tree into something else. The transformation\nperforms a depth-first, post-order …\n"],["Parslet::UnconsumedInput","","Parslet/UnconsumedInput.html","","<p>Raised when the parse operation didn’t consume all of its input. In this\ncase, it makes only limited …\n"],["+","Parslet::Slice","Parslet/Slice.html#method-i-2B","(other)","<p>Concatenate two slices; it is assumed that the second slice begins  where\nthe first one ends. The offset …\n"],["==","Parslet::Slice","Parslet/Slice.html#method-i-3D-3D","(other)","<p>Compares slices to other slices or strings.\n"],[">>","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-3E-3E","(parslet)","<p>Chains two parslet atoms together as a sequence.\n<p>Example:\n\n<pre>str('a') &gt;&gt; str('b')</pre>\n"],["absent?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-absent-3F","()","<p>Tests for absence of a parslet atom in the input stream without consuming\nit.\n<p>Example:\n\n<pre># Only proceed ...</pre>\n"],["absnt?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-absnt-3F","()","<p>Alias for absent? that will disappear in 2.0 (deprecated)\n"],["accept","Parslet::Atoms::Alternative","Parslet/Atoms/Alternative.html#method-i-accept","(visitor)","<p>Call back visitors #visit_alternative method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-accept","(visitor)",""],["accept","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-i-accept","(visitor)","<p>Call back visitors #visit_entity method. See parslet/export for an example.\n"],["accept","Parslet::Atoms::Lookahead","Parslet/Atoms/Lookahead.html#method-i-accept","(visitor)","<p>Call back visitors #visit_lookahead method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Named","Parslet/Atoms/Named.html#method-i-accept","(visitor)","<p>Call back visitors #visit_named method. See parslet/export for an example.\n"],["accept","Parslet::Atoms::Re","Parslet/Atoms/Re.html#method-i-accept","(visitor)","<p>Call back visitors #visit_re method. See parslet/export for an example.\n"],["accept","Parslet::Atoms::Repetition","Parslet/Atoms/Repetition.html#method-i-accept","(visitor)","<p>Call back visitors #visit_repetition method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Sequence","Parslet/Atoms/Sequence.html#method-i-accept","(visitor)","<p>Call back visitors #visit_sequence method. See parslet/export for an\nexample.\n"],["accept","Parslet::Atoms::Str","Parslet/Atoms/Str.html#method-i-accept","(visitor)","<p>Call back visitors #visit_str method. See parslet/export for an example.\n"],["accept","Parslet::Parser","Parslet/Parser.html#method-i-accept","(visitor)","<p>Call back visitors #visit_parser method.\n"],["access_cache","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-access_cache","(skip_adr)","<p>——————————————— interface for instructions\n"],["add","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-add","(instruction)",""],["address","Parslet::Bytecode::Compiler::Block","Parslet/Bytecode/Compiler/Block.html#method-i-address","()",""],["any","Parslet","Parslet.html#method-c-any","()","<p>Returns an atom matching any character. It acts like the ‘.’ (dot)\ncharacter in regular expressions. …\n"],["apply","Parslet::Transform","Parslet/Transform.html#method-i-apply","(obj, context=nil)","<p>Applies the transformation to a tree that is generated by Parslet::Parser\nor a simple parslet. Transformation …\n"],["as","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-as","(name)","<p>Marks a parslet atom as important for the tree output. This must be used \nto achieve meaningful output …\n"],["ascii_tree","Parslet::ErrorTree","Parslet/ErrorTree.html#method-i-ascii_tree","()","<p>Returns an ascii tree representation of the causes of this node and its\nchildren.\n"],["atom","Parslet::Bytecode::Compiler::Block","Parslet/Bytecode/Compiler/Block.html#method-i-atom","()",""],["buffer_pointer","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-buffer_pointer","()",""],["cache","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-i-cache","(obj, source, &block)","<p>Caches a parse answer for obj at source.pos. Applying the same parslet at\none position of input always …\n"],["call","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-call","(adr)",""],["call_on_match","Parslet::Transform","Parslet/Transform.html#method-i-call_on_match","(bindings, block)","<p>Executes the block on the bindings obtained by Pattern#match, if such a\nmatch can be made. Depending …\n"],["call_ret","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-call_ret","()",""],["cause","Parslet::ErrorTree","Parslet/ErrorTree.html#method-i-cause","()",""],["clear_error","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-clear_error","()",""],["compile","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-compile","(atom)",""],["current_address","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-current_address","()",""],["debug?","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-debug-3F","()",""],["discard_frame","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-discard_frame","()",""],["dump_state","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-dump_state","(ip_offset)","<p>Dumps the VM state so that the user can track errors down.\n"],["element_match","Parslet::Pattern","Parslet/Pattern.html#method-i-element_match","(tree, exp, bindings)","<p>Returns true if the tree element given by <code>tree</code> matches the\nexpression given by <code>exp</code>. This match must respect …\n"],["element_match_hash","Parslet::Pattern","Parslet/Pattern.html#method-i-element_match_hash","(tree, exp, bindings)",""],["emit_block","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-emit_block","()",""],["enter_frame","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-enter_frame","()",""],["eof?","Parslet::Source","Parslet/Source.html#method-i-eof-3F","()",""],["error","Parslet::Source","Parslet/Source.html#method-i-error","(message, error_pos=nil)","<p>Formats an error cause at the current position or at the position given  by\npos. If pos is nil, the current …\n"],["error?","Parslet::Atoms::Base::Fail","Parslet/Atoms/Base/Fail.html#method-i-error-3F","()",""],["error?","Parslet::Atoms::Base::Success","Parslet/Atoms/Base/Success.html#method-i-error-3F","()",""],["error_tree","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-error_tree","()","<p>Error tree returns what went wrong here plus what went wrong inside \nsubexpressions as a tree. The error …\n"],["fetch","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-fetch","()",""],["foldl","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-foldl","(list, &block)","<p>Lisp style fold left where the first element builds the basis for  an\ninject.\n"],["fwd_address","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-fwd_address","()",""],["init","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-init","(program, io)",""],["inspect","Parslet::Bytecode::Compiler::Address","Parslet/Bytecode/Compiler/Address.html#method-i-inspect","()",""],["inspect","Parslet::Slice","Parslet/Slice.html#method-i-inspect","()","<p>Prints the slice as <code>&quot;string&quot;@offset</code>.\n"],["jump","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-jump","(address)",""],["line_and_column","Parslet::Slice","Parslet/Slice.html#method-i-line_and_column","()","<p>Returns a &lt;line, column&gt; tuple referring to the original input.\n"],["line_and_column","Parslet::Source","Parslet/Source.html#method-i-line_and_column","(position=nil)","<p>Returns a &lt;line, column&gt; tuple for the given position. If no position\nis given, line/column information …\n"],["match","Parslet","Parslet.html#method-c-match","(str=nil)","<p>Returns an atom matching a character class. All regular expressions can be\nused, as long as they match …\n"],["match","Parslet::Pattern","Parslet/Pattern.html#method-i-match","(subtree, bindings=nil)","<p>Decides if the given subtree matches this pattern. Returns the bindings\nmade on a successful match or …\n"],["match","Parslet::Slice","Parslet/Slice.html#method-i-match","(regexp)","<p>Match regular expressions.\n"],["maybe","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-maybe","()","<p>Returns a new parslet atom that is only maybe present in the input. This is\nsynonymous to calling #repeat …\n"],["new","Parslet::Atoms::Alternative","Parslet/Atoms/Alternative.html#method-c-new","(*alternatives)","<p>Constructs an Alternative instance using all given parslets in the order\ngiven. This is what happens …\n"],["new","Parslet::Atoms::Context","Parslet/Atoms/Context.html#method-c-new","()",""],["new","Parslet::Atoms::Repetition","Parslet/Atoms/Repetition.html#method-c-new","(parslet, min, max, tag=:repetition)",""],["new","Parslet::Atoms::Sequence","Parslet/Atoms/Sequence.html#method-c-new","(*parslets)",""],["new","Parslet::Atoms::Str","Parslet/Atoms/Str.html#method-c-new","(str)",""],["new","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-c-new","()",""],["new","Parslet::Bytecode::Compiler::Address","Parslet/Bytecode/Compiler/Address.html#method-c-new","(address=nil)",""],["new","Parslet::Bytecode::Compiler::Block","Parslet/Bytecode/Compiler/Block.html#method-c-new","(name, block, compiler)",""],["new","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-c-new","(debug=false)",""],["new","Parslet::Expression","Parslet/Expression.html#method-c-new","(str, opts={}, context=self)","<p>Creates a parslet from a foreign language expression.\n<p>Example:\n\n<pre>Parslet::Expression.new(&quot;'a' 'b'&quot;)</pre>\n"],["new","Parslet::ParseFailed","Parslet/ParseFailed.html#method-c-new","(message, cause=nil)",""],["new","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-c-new","(context)",""],["new","Parslet::Pattern","Parslet/Pattern.html#method-c-new","(pattern)",""],["new","Parslet::Slice","Parslet/Slice.html#method-c-new","(string, offset, line_cache=nil)","<p>Construct a slice using a string, an offset and an optional line cache. \nThe line cache should be able …\n"],["new","Parslet::Source","Parslet/Source.html#method-c-new","(io)",""],["nodes","Parslet::ErrorTree","Parslet/ErrorTree.html#method-i-nodes","()",""],["parse","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-parse","(io, traditional=true)","<p>Given a string or an IO object, this will attempt a parse of its contents\nand return a result. If the …\n"],["parse","Parslet::Expression","Parslet/Expression.html#method-i-parse","(str)","<p>Parses the string and returns a parse tree.\n"],["parse_traditional","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-parse_traditional","(io)",""],["parse_vm","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-parse_vm","(io)",""],["parse_with_debug","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-parse_with_debug","(str)","<p>Packages the common idiom\n\n<pre class=\"ruby\"><span class=\"ruby-keyword\">begin</span>\n  <span class=\"ruby-identifier\">tree</span> = <span class=\"ruby-identifier\">parser</span>.<span class=\"ruby-identifier\">parse</span>(<span class=\"ruby-string\">'something'</span>)\n<span class=\"ruby-keyword\">rescue</span> <span class=\"ruby-constant\">Parslet</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">ParseFailed</span> =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-identifier\">error</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["parslet","Parslet::Atoms::Entity","Parslet/Atoms/Entity.html#method-i-parslet","()",""],["pop","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-pop","(n=nil)",""],["pos","Parslet::Source","Parslet/Source.html#method-i-pos","()",""],["pos=","Parslet::Source","Parslet/Source.html#method-i-pos-3D","(new_pos)",""],["present?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-present-3F","()","<p>Tests for presence of a parslet atom in the input stream without consuming\nit.\n<p>Example:\n\n<pre># Only proceed ...</pre>\n"],["prsnt?","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-prsnt-3F","()","<p>Alias for present? that will disappear in 2.0 (deprecated)\n"],["push","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-push","(value)",""],["read","Parslet::Source","Parslet/Source.html#method-i-read","(n)","<p>Reads n bytes from the input and returns a Range instance. If the n  bytes\nend in the middle of a multibyte …\n"],["repeat","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-repeat","(min=0, max=nil)","<p>Construct a new atom that repeats the current atom min times at least and\nat most max times. max can …\n"],["resolve","Parslet::Bytecode::Compiler::Address","Parslet/Bytecode/Compiler/Address.html#method-i-resolve","(vm)",""],["root","Parslet::Parser","Parslet/Parser.html#method-c-root","(name)","<p>Define the parsers #root function. This is the place where you start \nparsing; if you have a rule for …\n"],["rule","Parslet::ClassMethods","Parslet/ClassMethods.html#method-i-rule","(name, &definition)","<p>Define an entity for the parser. This generates a method of the same name\nthat can be used as part of …\n"],["rule","Parslet::Transform","Parslet/Transform.html#method-i-rule","(expression, &block)","<p>Defines a rule to be applied whenever apply is called on a tree. A rule is\ncomposed of two parts:\n<p>an …\n"],["rule","Parslet::Transform","Parslet/Transform.html#method-c-rule","(expression, &block)","<p>Define a rule for the transform subclass.\n"],["run","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-run","(program, io)",""],["sequence","Parslet","Parslet.html#method-c-sequence","(symbol)","<p>Returns a placeholder for a tree transformation that will only match a \nsequence of elements. The <code>symbol</code> …\n"],["set_error","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-set_error","(error)",""],["simple","Parslet","Parslet.html#method-c-simple","(symbol)","<p>Returns a placeholder for a tree transformation that will only match \nsimple elements. This matches everything …\n"],["size","Parslet::Slice","Parslet/Slice.html#method-i-size","()","<p>Returns the slices size in characters.\n"],["stop","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-stop","()",""],["store_cache","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-store_cache","(adr)",""],["str","Parslet","Parslet.html#method-c-str","(str)","<p>Returns an atom matching the <code>str</code> given.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">str</span>(<span class=\"ruby-string\">'class'</span>)      <span class=\"ruby-comment\"># will match 'class'</span>\n</pre>\n"],["subtree","Parslet","Parslet.html#method-c-subtree","(symbol)","<p>Returns a placeholder for tree transformation patterns that will match  any\nkind of subtree.\n<p>Example: …\n"],["success?","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-success-3F","()",""],["to_citrus","Parslet::Parser","Parslet/Parser.html#method-i-to_citrus","()","<p>Exports the current parser instance as a string in the Citrus dialect.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'parslet/export'</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["to_f","Parslet::Slice","Parslet/Slice.html#method-i-to_f","()",""],["to_i","Parslet::Slice","Parslet/Slice.html#method-i-to_i","()",""],["to_int","Parslet::Slice","Parslet/Slice.html#method-i-to_int","()",""],["to_parslet","Parslet::Expression","Parslet/Expression.html#method-i-to_parslet","()","<p>Turns this expression into a parslet.\n"],["to_s","Parslet::Bytecode::Compiler::Address","Parslet/Bytecode/Compiler/Address.html#method-i-to_s","()",""],["to_s","Parslet::ErrorTree","Parslet/ErrorTree.html#method-i-to_s","()",""],["to_s","Parslet::Slice","Parslet/Slice.html#method-i-to_s","()",""],["to_slice","Parslet::Slice","Parslet/Slice.html#method-i-to_slice","()",""],["to_str","Parslet::Slice","Parslet/Slice.html#method-i-to_str","()","<p>Conversion operators —————————————————–\n"],["to_sym","Parslet::Slice","Parslet/Slice.html#method-i-to_sym","()",""],["to_treetop","Parslet::Parser","Parslet/Parser.html#method-i-to_treetop","()","<p>Exports the current parser instance as a string in the Treetop dialect.\n<p>Example:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'parslet/export'</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["transform","Parslet::Expression","Parslet/Expression.html#method-i-transform","(tree)","<p>Transforms the parse tree into a parslet expression.\n"],["try","Parslet::Atoms::Base","Parslet/Atoms/Base.html#method-i-try","(source, context)","<p>Override this in your Atoms::Base subclasses to implement parsing\nbehaviour.\n"],["value_at","Parslet::Bytecode::VM","Parslet/Bytecode/VM.html#method-i-value_at","(ptr)",""],["visit_alternative","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_alternative","(alternatives)",""],["visit_alternative","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_alternative","(alternatives)",""],["visit_alternative","Parslet::Parser::Visitors::Treetop","Parslet/Parser/Visitors/Treetop.html#method-i-visit_alternative","(alternatives)",""],["visit_entity","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_entity","(name, block)",""],["visit_entity","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_entity","(name, block)",""],["visit_lookahead","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_lookahead","(positive, parslet)",""],["visit_lookahead","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_lookahead","(positive, bound_parslet)",""],["visit_named","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_named","(name, parslet)",""],["visit_named","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_named","(name, parslet)",""],["visit_parser","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_parser","(root)",""],["visit_re","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_re","(match)",""],["visit_re","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_re","(match)",""],["visit_repetition","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_repetition","(tag, min, max, parslet)",""],["visit_repetition","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_repetition","(tag, min, max, parslet)",""],["visit_repetition","Parslet::Parser::Visitors::Treetop","Parslet/Parser/Visitors/Treetop.html#method-i-visit_repetition","(tag, min, max, parslet)",""],["visit_sequence","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_sequence","(parslets)",""],["visit_sequence","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_sequence","(parslets)",""],["visit_str","Parslet::Bytecode::Compiler","Parslet/Bytecode/Compiler.html#method-i-visit_str","(str)",""],["visit_str","Parslet::Parser::Visitors::Citrus","Parslet/Parser/Visitors/Citrus.html#method-i-visit_str","(str)",""],["warn_about_duplicate_keys","Parslet::Atoms::CanFlatten","Parslet/Atoms/CanFlatten.html#method-i-warn_about_duplicate_keys","(h1, h2)","<p>That annoying warning ‘Duplicate subtrees while merging result’ comes  from\nhere. You should add more …\n"],["|","Parslet::Atoms::DSL","Parslet/Atoms/DSL.html#method-i-7C","(parslet)","<p>Chains two parslet atoms together to express alternation. A match will\nalways be attempted with the parslet …\n"],["README","","README.html","","<p>INTRODUCTION\n<p>Parslet makes developing complex parsers easy. It does so by\n<p>providing the best error reporting …\n"]]}}