<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html;charset=UTF-8" http-equiv="Content-type" />
    <title>
      parslet -
      Transformation
    </title>
    <meta content="Kaspar Schiess (http://absurd.li)" name="author" />
    <link href="css/site.css" rel="stylesheet" type="text/css" />
    <link href="css/pygments.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="everything">
      <div class="main_menu">
        <img alt="Parslet Logo" src="imgs/parsley_logo.png" />
        <ul>
          <li><a href="index.html">about</a></li>
          <li><a href="get-started.html">get started</a></li>
          <li><a href="install.html">install</a></li>
          <li><a href="documentation.html">documentation</a></li>
          <li><a href="contribute.html">contribute</a></li>
        </ul>
      </div>
      <div class="content">
        <h1>Transformation</h1>
        <p>Parslet parsers output deep nested hashes. Those are nice for printing, but 
        hard to work with. The structure of the nested hashes is determined by the
        grammar and can thus vary largely. Testing for the presence of individual 
        keys would produce code that is hard to read and maintain.</p>
        <p>This is why parslet also comes with a hash transformation engine. To construct
        such a transform, you have to derive from <code>Parslet::Transform</code>:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="k">class</span> <span class="nc">MyTransform</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Transform</span>
          <span class="n">rule</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="s1">&#39;b&#39;</span> <span class="p">}</span>
        <span class="k">end</span>
        <span class="no">MyTransform</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1"># =&gt; &#39;b&#39;</span>
        </code></pre>
        </div><p>This is a transformation that replaces all &#8217;a&#8217;s with &#8217;b&#8217;s. A transformation
        rule has two parts: A <strong>pattern</strong> (here: <code>'a'</code>) and an <strong>action block</strong>
        (<code>{ 'b' }</code>).</p>
        <p>The engine will go through the input and traverse the tree in depth-first
        post-order fashion. This means that for a given tree node, it will first visit
        the children and only then look at the node itself. While traversing, all
        rules are tested in the order in which they are defined. If a rule matches, the
        corresponding tree is <em>replaced</em> by whatever the action block returns.</p>
        <p>Here&#8217;s another way of saying the same thing, perhaps more in line with what 
        you need as a user of Parslet: <code>Parslet::Transform</code> is what allows
        you to transform the <span class="caps">PORO</span>-trees magically into a real abstract syntax tree. The
        rule definitions are the futuristic nano-machines that act on tree leaves first, 
        eating them away and replacing them with contraptions of your own design. Here&#8217;s
        how that might look like in Ruby:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">tree</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:left</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="ss">:int</span> <span class="o">=&gt;</span> <span class="s1">&#39;1&#39;</span><span class="p">},</span> 
                <span class="ss">:op</span>   <span class="o">=&gt;</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> 
                <span class="ss">:right</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="ss">:int</span> <span class="o">=&gt;</span> <span class="s1">&#39;2&#39;</span><span class="p">}}</span>
                
        <span class="k">class</span> <span class="nc">Trans</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Transform</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:int</span> <span class="o">=&gt;</span> <span class="n">simple</span><span class="p">(</span><span class="ss">:x</span><span class="p">))</span> <span class="p">{</span> <span class="nb">Integer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">end</span>
        <span class="no">Trans</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>     <span class="c1"># =&gt; {:op=&gt;&quot;+&quot;, :right=&gt;2, :left=&gt;1}</span>
        </code></pre>
        </div><p>You can start thinking about the leaves first, transforming those <code>:int
        =&gt; '1'</code> into real Ruby integers. This incremental (test driven!)
        approach will prevent your intermediary tree from turning into grey goo
        from too many nano-machines. Rules should in general be simple and transform
        a small part of the tree into a more useful variant. Turns out that if we were
        looking for an interpreter, one more rule will give us evaluation:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="c1"># ... snippage ...</span>
        
        <span class="k">class</span> <span class="nc">Trans</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Transform</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:int</span> <span class="o">=&gt;</span> <span class="n">simple</span><span class="p">(</span><span class="ss">:x</span><span class="p">))</span> <span class="p">{</span> <span class="nb">Integer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:op</span> <span class="o">=&gt;</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="ss">:left</span> <span class="o">=&gt;</span> <span class="n">simple</span><span class="p">(</span><span class="ss">:l</span><span class="p">),</span> <span class="ss">:right</span> <span class="o">=&gt;</span> <span class="n">simple</span><span class="p">(</span><span class="ss">:r</span><span class="p">))</span> <span class="p">{</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="p">}</span>
        <span class="k">end</span>
        <span class="no">Trans</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>     <span class="c1"># =&gt; 3</span>
        </code></pre>
        </div><p>Cool, isn&#8217;t it? To recap: parslet intentionally spits out deep nested hashes, 
        because it also gives you the tool to work with those. Turning the intermediary
        trees into something useful is really easy.</p>
        <h2>Working with Captures</h2>
        <p>What is this <code>simple(symbol)</code> business all about, you might ask.
        Glad you do.</p>
        <h3>Simple captures</h3>
        <p>Transform allows you to specify patterns that have wildcards in them. The
        wildcards match part of the tree, but at the same time capture it for working
        on it in your action block. The wildcard</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">simple</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span>
        </code></pre>
        </div><p>will match any object <span class="caps">BUT</span> hashes or arrays. While this is obviously useful
        for capturing strings, you can also capture other &#8216;simple&#8217; (as opposed to 
        composed) objects of your own creation. <code>simple(:x)</code> would thus match
        all of these objects:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="s2">&quot;a string&quot;</span>
        <span class="mi">123</span>
        <span class="no">Foo</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:some</span><span class="p">,</span> <span class="ss">:class</span><span class="p">,</span> <span class="ss">:instance</span><span class="p">)</span>
        </code></pre>
        </div><p>If you think about what you&#8217;ll be doing to your intermediary trees, replacing
        leaves with more useful objects, <code>simple</code> really makes good sense, 
        since it will stop you from matching entire subtrees.</p>
        <h3>sequence</h3>
        <h3>subtree</h3>
        <h2>Transformation rules</h2>
        <h3>patterns</h3>
        <h3>Action blocks: Two flavors</h3>
        <h3>why doesn&#8217;t it loop around?</h3>
        <h3>Ruledefs: Two flavors</h3>
      </div>
      <div class="copyright">
        <p><span class="caps">MIT</span> License, 2010, &#169; <a href="http://absurd.li">Kaspar Schiess</a><br/>
        Logo by <a href="http://floere.github.com">Florian Hanke</a>, <a href="http://creativecommons.org/licenses/by/1.0/">CC Attribution</a> license</p>
      </div>
      <script type="text/javascript">
        //<![CDATA[
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-16365074-2']);
          _gaq.push(['_trackPageview']);
          
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        //]]>
      </script>
    </div>
  </body>
</html>
