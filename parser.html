<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html;charset=UTF-8" http-equiv="Content-type" />
    <title>
      parslet -
      Parser construction
    </title>
    <meta content="Kaspar Schiess (http://absurd.li)" name="author" />
    <link href="css/site.css" rel="stylesheet" type="text/css" />
    <link href="css/pygments.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="everything">
      <div class="main_menu">
        <img alt="Parslet Logo" src="imgs/parsley_logo.png" />
        <ul>
          <li><a href="index.html">about</a></li>
          <li><a href="get-started.html">get started</a></li>
          <li><a href="install.html">install</a></li>
          <li><a href="documentation.html">documentation</a></li>
          <li><a href="contribute.html">contribute</a></li>
        </ul>
      </div>
      <div class="content">
        <h1>Parser construction</h1>
        <p>A parser is nothing more than a class that derives from
        <code>Parslet::Parser</code>. The simplest parser that one could write would
        look like this:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="k">class</span> <span class="nc">SimpleParser</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Parser</span>
          <span class="n">rule</span><span class="p">(</span><span class="ss">:a_rule</span><span class="p">)</span> <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;simple_parser&#39;</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">root</span><span class="p">(</span><span class="ss">:a_rule</span><span class="p">)</span>
        <span class="k">end</span>
        </code></pre>
        </div><p>The language recognized by this parser is simply the string &#8220;simple_parser&#8221;. 
        Parser rules do look a lot like methods and are defined by</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">rule</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="p">{</span> <span class="n">definition_block</span> <span class="p">}</span>
        </code></pre>
        </div><p>Behind the scenes, this really defines a method that returns whatever you 
        return from it.</p>
        <p>Every parser has a root. This designates where parsing should start. It is like
        an entry point to your parser. With a root defined like this:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">root</span><span class="p">(</span><span class="ss">:my_root</span><span class="p">)</span>
        </code></pre>
        </div><p>you create a <code>#parse</code> method in your parser that will start parsing
        by calling the <code>#my_root</code> method. You&#8217;ll also have a <code>#root</code>
        (instance) method that is an alias of the root method. The following things are
        really one and the same:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="no">SimpleParser</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="no">SimpleParser</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="no">SimpleParser</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">a_rule</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        </code></pre>
        </div><p>Knowing these things gives you a lot of flexibility; I&#8217;ll explain why at the
        end of the chapter. For now, just let me point out that because all of this is
        Ruby, your favorite editor will syntax highlight parser code just fine.</p>
        <h2>Atoms: The inside of a parser</h2>
        <h3>Matching strings of characters</h3>
        <p>A parser is constructed from parser atoms (or parslets, hence the name). The
        atoms are what appear inside your rules (and maybe elsewhere). We&#8217;ve already
        encountered an atom, the string atom:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;simple_parser&#39;</span><span class="p">)</span>
        </code></pre>
        </div><p>This returns a <code>Parslet::Atoms::Str</code> instance. These parser atoms
        all derive from <code>Parslet::Atoms::Base</code> and have essentially just
        one method you can call: <code>#parse</code>. So this works:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foobar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;foobar&#39;</span><span class="p">)</span> <span class="c1"># =&gt; &#39;foobar&#39;</span>
        </code></pre>
        </div><p>The atoms are small parsers that can recognize languages and throw errors, just
        like real <code>Parslet::Parser</code> subclasses.</p>
        <h3>Matching character ranges</h3>
        <p>The second parser atom you will have to know about allows you to match
        character ranges:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[0-9a-f]&#39;</span><span class="p">)</span>
        </code></pre>
        </div><p>The above atom would match the numbers zero through nine and the letters &#8216;a&#8217; 
        to &#8216;f&#8217; &#8211; yeah, you guessed right &#8211; hexadecimal numbers for example. The inside
        of such a match parslet is essentially a regular expression that matches 
        a single character of input. Because we&#8217;ll be using ranges so much with 
        <code>#match</code> and because typing (&#8216;[]&#8217;) is tiresome, here&#8217;s another way
        to write the above <code>#match</code> atom:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">match</span><span class="o">[</span><span class="s1">&#39;0-9a-f&#39;</span><span class="o">]</span>
        </code></pre>
        </div><p>Character matches are instances of <code>Parslet::Atoms::Re</code>. Here are 
        some more examples of character ranges:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">match</span><span class="o">[</span><span class="s1">&#39;[:alnum:]&#39;</span><span class="o">]</span>      <span class="c1"># letters and numbers</span>
        <span class="n">match</span><span class="o">[</span><span class="s1">&#39;\\n&#39;</span><span class="o">]</span>            <span class="c1"># newlines</span>
        <span class="n">match</span><span class="p">(</span><span class="s1">&#39;\\w&#39;</span><span class="p">)</span>            <span class="c1"># word characters</span>
        <span class="n">match</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>              <span class="c1"># any character</span>
        </code></pre>
        </div><h3>The wild wild <code>#any</code></h3>
        <p>The last example above corresponds to the regular expression <code>/./</code> that matches
        any one character. There is a special atom for that:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">any</span> 
        </code></pre>
        </div><h2>Composition of Atoms</h2>
        <p>These basic atoms can be composed to form complex grammars. The following
        few sections will tell you about the various ways atoms can be composed.</p>
        <h3>Simple Sequences</h3>
        <p>Match &#8216;foo&#8217; and then &#8216;bar&#8217;:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>    <span class="c1"># same as str(&#39;foobar&#39;)</span>
        </code></pre>
        </div><p>Sequences correspond to instances of the class
        <code>Parslet::Atoms::Sequence</code>.</p>
        <h3>Repetition and its Special Cases</h3>
        <p>To model atoms that can be repeated, you should use <code>#repeat</code>:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span>
        </code></pre>
        </div><p>This will allow foo to repeat any number of times, including zero. If you
        look at the signature for <code>#repeat</code> in <code>Parslet::Atoms::Base</code>, 
        you&#8217;ll see that it has really two arguments: <em>min</em> and <em>max</em>. So the following
        code all makes sense:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># match &#39;foo&#39; at least once</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>    <span class="c1"># at least once and at most 3 times</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kp">nil</span><span class="p">)</span> <span class="c1"># the default: same as str(&#39;foo&#39;).repeat</span>
        </code></pre>
        </div><p>Repetition has a special case that is used frequently: Matching something
        once or not at all can be achieved by <code>repeat(0,1)</code>, but also 
        through the prettier:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">maybe</span>          <span class="c1"># same as str(&#39;foo&#39;).repeat(0,1)</span>
        </code></pre>
        </div><p>These all map to <code>Parslet::Atoms::Repetition</code></p>
        <h3>Alternation</h3>
        <p>The most important composition method for grammars is alternation. Without
        it, your grammars would only vary in the amount of things matched, but not
        in content. Here&#8217;s how this looks:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>   <span class="c1"># matches &#39;foo&#39; OR &#39;bar&#39;</span>
        </code></pre>
        </div><p>This reads naturally as &#8220;&#8216;foo&#8217; or &#8216;bar&#8217;&#8221;.</p>
        <h3>Operator precedence</h3>
        <p>The operators we have chosen for parslet atom combination have the operator
        precedence that you would expect. No parenthesis are needed to express
        alternation of sequences:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;equence&#39;</span><span class="p">)</span> <span class="o">|</span> 
          <span class="n">str</span><span class="p">(</span><span class="s1">&#39;se&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;quence&#39;</span><span class="p">)</span>
        </code></pre>
        </div><h3>And more</h3>
        <p>Parslet atoms are not as pretty as Treetop atoms. There you go, we said it. 
        However, there seems to be a different kind of aesthetic about them; they 
        are pure Ruby and integrate well with the rest of your environment. Have a 
        look at this:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="c1"># Also consumes the space after important things like &#39;;&#39; or &#39;:&#39;. Call this</span>
        <span class="c1"># giving the character you want to match as argument: </span>
        <span class="c1">#</span>
        <span class="c1">#   arg &gt;&gt; (spaced(&#39;,&#39;) &gt;&gt; arg).repeat</span>
        <span class="c1">#</span>
        <span class="k">def</span> <span class="nf">spaced</span><span class="p">(</span><span class="n">character</span><span class="p">)</span>
          <span class="n">str</span><span class="p">(</span><span class="n">character</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">match</span><span class="o">[</span><span class="s2">&quot;</span><span class="se">\s</span><span class="s2">&quot;</span><span class="o">]</span>
        <span class="k">end</span>
        </code></pre>
        </div><p>or even this:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="c1"># Turns any atom into an expression that matches a left parenthesis, the </span>
        <span class="c1"># atom and then a right parenthesis.</span>
        <span class="c1">#</span>
        <span class="c1">#   bracketed(sum)</span>
        <span class="c1">#</span>
        <span class="k">def</span> <span class="nf">bracketed</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
          <span class="n">spaced</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">atom</span> <span class="o">&gt;&gt;</span> <span class="n">spaced</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="k">end</span>
        </code></pre>
        </div><p>You might say that because parslet is just plain old Ruby objects itself (<span class="caps">PORO</span>
        &#8482;), it allows for very tight code. Module inclusion, class inheritance, &#8230;
        all your tools should work well with parslet.</p>
        <h2>Tree construction</h2>
        <p>By default, parslet will just echo back to you the strings you feed into it. 
        Parslet will not generate a parser for you and neither will it generate your
        abstract syntax tree for you. The method <code>#as(name)</code> allows you
        to specify exactly how you want your tree to look like:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>             <span class="c1"># =&gt; &#39;foo&#39;</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:bar</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>    <span class="c1"># =&gt; {:bar =&gt; &#39;foo&#39;}</span>
        </code></pre>
        </div><p>So you think: <code>#as(name)</code> allows me to create a hash, big deal.
        That&#8217;s not all. You&#8217;ll notice that annotating everything that you want to keep
        in your grammar with <code>#as(name)</code> autocreates a sensible tree
        composed of hashes and arrays and strings. It&#8217;s really somewhat magic: Parslet
        has a set of clever rules that merge the annotated output from your atoms into
        a tree. Here are some more examples, with the atom on the left and the resulting
        tree (assuming a successful parse) on the right:</p>
        <div class="highlight"><pre><code class="ruby"> 
        <span class="c1"># Normal strings just map to strings</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span>                          <span class="s2">&quot;aaa&quot;</span>                                   
        
        <span class="c1"># Arrays capture repetition of non-strings</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:b</span><span class="p">)</span>                   <span class="p">{</span><span class="ss">:b</span><span class="o">=&gt;</span><span class="s2">&quot;aaa&quot;</span><span class="p">}</span>                             
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:b</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span>                   <span class="o">[</span><span class="p">{</span><span class="ss">:b</span><span class="o">=&gt;</span><span class="s2">&quot;a&quot;</span><span class="p">},</span> <span class="p">{</span><span class="ss">:b</span><span class="o">=&gt;</span><span class="s2">&quot;a&quot;</span><span class="p">},</span> <span class="p">{</span><span class="ss">:b</span><span class="o">=&gt;</span><span class="s2">&quot;a&quot;</span><span class="p">}</span><span class="o">]</span>       
        
        <span class="c1"># Subtrees get merged - unlabeled strings discarded</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:a</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:b</span><span class="p">)</span>       <span class="p">{</span><span class="ss">:a</span><span class="o">=&gt;</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="ss">:b</span><span class="o">=&gt;</span><span class="s2">&quot;b&quot;</span><span class="p">}</span>                      
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:b</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>  <span class="p">{</span><span class="ss">:b</span><span class="o">=&gt;</span><span class="s2">&quot;b&quot;</span><span class="p">}</span>                               
        
        <span class="c1"># #maybe will return nil, not the empty array</span>
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">maybe</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:a</span><span class="p">)</span>                    <span class="p">{</span><span class="ss">:a</span><span class="o">=&gt;</span><span class="s2">&quot;a&quot;</span><span class="p">}</span>                               
        <span class="n">str</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">maybe</span><span class="o">.</span><span class="n">as</span><span class="p">(</span><span class="ss">:a</span><span class="p">)</span>                    <span class="p">{</span><span class="ss">:a</span><span class="o">=&gt;</span><span class="kp">nil</span><span class="p">}</span>                               
        </code></pre>
        </div><h2>And more</h2>
        <p>Now you know exactly how to create parsers using Parslet. Your parsers
        will output intricate structures made of endless arrays, complex hashes and 
        a few string leftovers. But your programming skills fail you when you try
        to put all this data to use. Selecting keys upon keys in hash after hash, you
        feel like a cockroach that has just read Kafka&#8217;s works.</p>
        <p>Time to introduce you to <a href="transform.html">Parslet::Transform</a> and its workings.</p>
      </div>
      <div class="copyright">
        <p><span class="caps">MIT</span> License, 2010, &#169; <a href="http://absurd.li">Kaspar Schiess</a><br/>
        Logo by <a href="http://floere.github.com">Florian Hanke</a>, <a href="http://creativecommons.org/licenses/by/1.0/">CC Attribution</a> license</p>
      </div>
      <script type="text/javascript">
        //<![CDATA[
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-16365074-2']);
          _gaq.push(['_trackPageview']);
          
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        //]]>
      </script>
    </div>
  </body>
</html>
